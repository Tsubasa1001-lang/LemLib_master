# LemLib 感測器功能說明

> **專案名稱**: LemLib_1009  
> **版本**: 0.6.0  
> **目標平台**: VEX V5 機器人系統  
> **建立日期**: 2025年11月8日

---

## 1. 慣性測量單元 (IMU)

### 1.1 建立方式

```cpp
// 直接建立 (埠號 1)
lemlib::V5InertialSensor imu(1);

// 從 PROS IMU 轉換
pros::Imu prosImu(1);
lemlib::V5InertialSensor imu = lemlib::V5InertialSensor::from_pros_imu(prosImu);
```

### 1.2 常用指令

| 功能 | 指令 | 備註 |
|------|------|------|
| 校準 | `imu.calibrate()` | 校準時需保持靜止 (約 2-3 秒) |
| 檢查是否已校準 | `imu.isCalibrated()` | 回傳 1 / 0 |
| 檢查是否正在校準 | `imu.isCalibrating()` | 可搭配 `pros::delay` 等待完成 |
| 檢查連線 | `imu.isConnected()` | 0 代表硬體未偵測 |
| 讀取旋轉角 | `imu.getRotation()` | 無界角度，可超過 360° |
| 讀取航向 | `imu.getHeading()` | 0° ~ 360° 範圍 |
| 讀取角速度 | `imu.getAngularVelocity()` | 單位 `_degps` |
| 讀取加速度 | `imu.getAcceleration()` | 回傳 `Vector3D<Acceleration>` |
| 設置旋轉 | `imu.setRotation(angle)` | 重設參考角 |

#### 範例：初始化流程

```cpp
void initializeImu() {
    lemlib::V5InertialSensor imu(1);

    printf("開始校準 IMU...\n");
    imu.calibrate();
    while (imu.isCalibrating()) {
        pros::delay(100);
    }

    if (!imu.isConnected()) {
        pros::lcd::print(0, "ERROR: IMU not found!");
        return;
    }

    Angle heading = imu.getHeading();
    printf("航向: %.2f 度\n", to_stDeg(heading));
}
```

---

## 2. 編碼器 (Encoder)

MotorGroup 即繼承自 encoder 介面，因此可以直接使用下列方法：

```cpp
lemlib::V5RotationSensor encoder(3, true);

Angle angle = encoder.getAngle();
encoder.setAngle(0_stDeg);
AngularVelocity vel = encoder.getVelocity();

if (encoder.isConnected()) {
    printf("Encoder ready!\n");
}
```

這些方法也適用於 ADI Encoder 或對應的子類別。

---

## 3. 追蹤輪 (TrackingWheel)

### 3.1 建立追蹤輪

```cpp
// 使用 Rotation Sensor
lemlib::V5RotationSensor encoder(3, true);  // 埠 3，反轉
lemlib::TrackingWheel wheel(&encoder, 2.75_in, -3_in);

// 使用 ADI 埠
lemlib::TrackingWheel vertical('E', 'F', true, 2.75_in, 13.25_cm);

// 帶齒輪比
lemlib::TrackingWheel geared('A', 'B', false, 2.75_in, 0_in, 36.0/60.0);
```

**參數說明**  
- **編碼器埠**: ADI `'A' ~ 'H'` 或智慧埠 `1 ~ 21`  
- **反轉**: `true` 代表讀值取負號以符合座標系  
- **輪徑**: 追蹤輪直徑，影響位移換算  
- **偏移**: 與旋轉中心的距離，正值表示右/前，負值表示左/後  
- **齒輪比**: `驅動 / 從動`，預設 1

### 3.2 常用方法

```cpp
Length distance = trackingWheel.getDistanceTraveled();
trackingWheel.reset();
LinearVelocity vel = trackingWheel.getVelocity();

printf("移動距離: %.2f in\n", to_in(distance));
```

---

## 4. 感測器監控與故障排除

### 4.1 即時監控

```cpp
void monitorSensors() {
    while (true) {
        if (imu.isConnected()) {
            Angle heading = imu.getHeading();
            pros::lcd::print(7, "Heading: %.1f deg", to_stDeg(heading));
        } else {
            pros::lcd::print(7, "IMU Disconnected!");
        }

        Length delta = trackingWheel.getDistanceTraveled();
        pros::lcd::print(6, "Vertical: %.1f in", to_in(delta));
        pros::delay(100);
    }
}
```

### 4.2 常見錯誤對照

| 錯誤類型 | 可能原因 | 解決方法 |
|----------|----------|----------|
| IMU 校準失敗 | 機器人移動、磁場干擾 | 校準時保持靜止、遠離磁性物體 |
| IMU 無法連線 | 接線鬆脫、埠號錯誤 | 重新插拔、檢查程式埠號 |
| 編碼器讀值異常 | 連接問題、感測器損壞 | 檢查接線、更換編碼器 |
| 追蹤輪位移跳躍 | 輪徑設定錯誤、打滑 | 重新校準輪徑、檢查壓力 |

---

## 5. 快速參考表

| 功能 | 指令 | 範例 |
|------|------|------|
| 校準 IMU | `calibrate()` | `imu.calibrate()` |
| 檢查校準 | `isCalibrated()` | `if (imu.isCalibrated())` |
| 讀取旋轉 | `getRotation()` | `Angle r = imu.getRotation()` |
| 讀取航向 | `getHeading()` | `Angle h = imu.getHeading()` |
| 設置旋轉 | `setRotation(angle)` | `imu.setRotation(0_stDeg)` |
| 追蹤輪距離 | `getDistanceTraveled()` | `to_in(vertical.getDistanceTraveled())` |
| 追蹤輪重置 | `reset()` | `vertical.reset()` |

---

更多硬體控制與數學運算細節請參考 `docs/功能說明文檔.md` 及相關拆分文檔。
