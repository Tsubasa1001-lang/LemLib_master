# LemLib API åƒè€ƒæ–‡æª”

> **å°ˆæ¡ˆåç¨±**: LemLib_1009  
> **ç‰ˆæœ¬**: 0.6.0  
> **ç›®æ¨™å¹³å°**: VEX V5 æ©Ÿå™¨äººç³»çµ±  
> **å»ºç«‹æ—¥æœŸ**: 2025å¹´11æœˆ8æ—¥  

---

## ğŸ“‹ ç›®éŒ„

### ğŸ”§ ç¡¬é«”æ§åˆ¶
1. [é¦¬é”æ§åˆ¶ (MotorGroup)](#é¦¬é”æ§åˆ¶-motorgroup)
2. [æ„Ÿæ¸¬å™¨ API](#æ„Ÿæ¸¬å™¨-api)
   - [æ…£æ€§æ¸¬é‡å–®å…ƒ (IMU)](#æ…£æ€§æ¸¬é‡å–®å…ƒ-imu)
   - [ç·¨ç¢¼å™¨ (Encoder)](#ç·¨ç¢¼å™¨-encoder)
   - [è¿½è¹¤è¼ª (TrackingWheel)](#è¿½è¹¤è¼ª-trackingwheel)

### ğŸ“ æ•¸å€¼é‹ç®—
3. [å–®ä½ç³»çµ±](#å–®ä½ç³»çµ±)
4. [æ•¸å­¸å·¥å…·å‡½æ•¸](#æ•¸å­¸å·¥å…·å‡½æ•¸)
5. [è§’åº¦èˆ‡ä½ç½®è¨ˆç®—](#è§’åº¦èˆ‡ä½ç½®è¨ˆç®—)

### ğŸ® é‹å‹•æ§åˆ¶
6. [é‹å‹•æ§åˆ¶æŒ‡ä»¤](#é‹å‹•æ§åˆ¶æŒ‡ä»¤)
7. [PID æ§åˆ¶å™¨](#pid-æ§åˆ¶å™¨)
8. [é‡Œç¨‹è¨ˆç³»çµ±](#é‡Œç¨‹è¨ˆç³»çµ±)

### ğŸ“š å¯¦ç”¨ç¯„ä¾‹
9. [å¸¸ç”¨ç¨‹å¼ç¢¼ç¯„ä¾‹](#å¸¸ç”¨ç¨‹å¼ç¢¼ç¯„ä¾‹)

---

## ğŸ”§ é¦¬é”æ§åˆ¶ (MotorGroup)

### ğŸ“– æ¦‚è¿°
MotorGroup æ˜¯é¦¬é”ç¾¤çµ„æ§åˆ¶é¡ï¼Œå¯ä»¥åŒæ™‚æ§åˆ¶å¤šå€‹é¦¬é”ã€‚

### ğŸ¯ å‰µå»ºé¦¬é”ç¾¤çµ„

```cpp
// åŸºæœ¬å‰µå»º
lemlib::MotorGroup motors({1, -2, 3}, 360_rpm);
// åŸ è™Ÿ: 1, 2(åè½‰), 3
// æœ€å¤§é€Ÿåº¦: 360 RPM

// å¾ PROS MotorGroup å‰µå»º
pros::MotorGroup prosGroup({1, -2, 3});
lemlib::MotorGroup motors = lemlib::MotorGroup::from_pros_group(prosGroup, 360_rpm);
```

**åƒæ•¸èªªæ˜**:
- **åŸ è™Ÿåˆ—è¡¨**: `{1, -2, 3}` - è² è™Ÿè¡¨ç¤ºåè½‰
- **è¼¸å‡ºé€Ÿåº¦**: `360_rpm`, `200_rpm`, `600_rpm` (V5 é¦¬é”æª”ä½)

---

### âš¡ é¦¬é”æ§åˆ¶æŒ‡ä»¤

#### 1. `move()` - æŒ‰ç™¾åˆ†æ¯”åŠŸç‡ç§»å‹•
```cpp
int move(Number percent);
```

**åƒæ•¸**: 
- `percent`: -1.0 åˆ° 1.0 çš„åŠŸç‡å€¼

**è¿”å›å€¼**:
- `0`: æˆåŠŸ
- `INT_MAX`: å¤±æ•—

**ç¯„ä¾‹**:
```cpp
motors.move(0.5);    // 50% æ­£å‘åŠŸç‡
motors.move(-0.5);   // 50% åå‘åŠŸç‡
motors.move(1.0);    // 100% å…¨é€Ÿå‰é€²
motors.move(0);      // åœæ­¢
```

---

#### 2. `moveVelocity()` - æŒ‰è§’é€Ÿåº¦ç§»å‹•
```cpp
int moveVelocity(AngularVelocity velocity);
```

**åƒæ•¸**:
- `velocity`: ç›®æ¨™è§’é€Ÿåº¦

**ç¯„ä¾‹**:
```cpp
motors.moveVelocity(50_degps);     // 50 åº¦/ç§’
motors.moveVelocity(-100_rpm);     // -100 è½‰/åˆ†
motors.moveVelocity(180_degps);    // 180 åº¦/ç§’
motors.moveVelocity(0_degps);      // åœæ­¢
```

**é€Ÿåº¦å–®ä½**:
- `_degps`: åº¦/ç§’
- `_rpm`: è½‰/åˆ†é˜

---

#### 3. `brake()` - ç…è»Š
```cpp
int brake();
```

ä½¿ç”¨è¨­å®šçš„ç…è»Šæ¨¡å¼åœæ­¢é¦¬é”ã€‚

**ç¯„ä¾‹**:
```cpp
motors.move(0.8);     // ä»¥ 80% åŠŸç‡å‰é€²
pros::delay(1000);    // ç­‰å¾… 1 ç§’
motors.brake();       // ç…è»Šåœæ­¢
```

---

#### 4. `setBrakeMode()` - è¨­ç½®ç…è»Šæ¨¡å¼
```cpp
int setBrakeMode(BrakeMode mode);
```

**ç…è»Šæ¨¡å¼**:
- `lemlib::BrakeMode::COAST` - æ»‘è¡Œ (ç„¡é˜»åŠ›)
- `lemlib::BrakeMode::BRAKE` - ç…è»Š (æœ‰é˜»åŠ›)
- `lemlib::BrakeMode::HOLD` - ä¿æŒä½ç½® (ä¼ºæœæ¨¡å¼)

**ç¯„ä¾‹**:
```cpp
// æ»‘è¡Œæ¨¡å¼ - åœæ­¢å¾Œè‡ªç”±æ»¾å‹•
motors.setBrakeMode(lemlib::BrakeMode::COAST);

// ç…è»Šæ¨¡å¼ - åœæ­¢å¾Œæœ‰é˜»åŠ›
motors.setBrakeMode(lemlib::BrakeMode::BRAKE);

// ä¿æŒæ¨¡å¼ - ä¸»å‹•ä¿æŒç•¶å‰ä½ç½®
motors.setBrakeMode(lemlib::BrakeMode::HOLD);
```

---

#### 5. `getBrakeMode()` - ç²å–ç…è»Šæ¨¡å¼
```cpp
BrakeMode getBrakeMode();
```

**ç¯„ä¾‹**:
```cpp
lemlib::BrakeMode mode = motors.getBrakeMode();
if (mode == lemlib::BrakeMode::BRAKE) {
    printf("ç•¶å‰ç‚ºç…è»Šæ¨¡å¼\n");
}
```

---

### ğŸ“Š é¦¬é”ç‹€æ…‹æŸ¥è©¢

#### 6. `isConnected()` - æª¢æŸ¥é€£æ¥ç‹€æ…‹
```cpp
int isConnected();
```

**è¿”å›å€¼**:
- `1`: è‡³å°‘ä¸€å€‹é¦¬é”å·²é€£æ¥
- `0`: æ‰€æœ‰é¦¬é”æœªé€£æ¥

**ç¯„ä¾‹**:
```cpp
if (motors.isConnected()) {
    printf("é¦¬é”å·²é€£æ¥\n");
} else {
    printf("é¦¬é”æœªé€£æ¥\n");
}
```

---

#### 7. `getAngle()` - ç²å–è§’åº¦
```cpp
Angle getAngle();
```

ç²å–é¦¬é”çš„ç›¸å°è§’åº¦ï¼ˆç›¸å°æ–¼ä¸Šæ¬¡é‡ç½®ï¼‰ã€‚

**è¿”å›å€¼**:
- `Angle`: è§’åº¦å€¼
- `INFINITY`: éŒ¯èª¤

**ç¯„ä¾‹**:
```cpp
Angle angle = motors.getAngle();
if (angle != INFINITY) {
    printf("é¦¬é”è§’åº¦: %.2f åº¦\n", to_stDeg(angle));
}
```

---

#### 8. `setAngle()` - è¨­ç½®è§’åº¦
```cpp
int setAngle(Angle angle);
```

è¨­ç½®é¦¬é”çš„ç›¸å°è§’åº¦ï¼ˆé‡ç½®åƒè€ƒé»ï¼‰ã€‚

**ç¯„ä¾‹**:
```cpp
motors.setAngle(0_stDeg);     // é‡ç½®ç‚º 0 åº¦
motors.setAngle(90_stDeg);    // è¨­ç½®ç‚º 90 åº¦
```

---

#### 9. `getVelocity()` - ç²å–é€Ÿåº¦
```cpp
AngularVelocity getVelocity();
```

**ç¯„ä¾‹**:
```cpp
AngularVelocity vel = motors.getVelocity();
printf("ç•¶å‰é€Ÿåº¦: %.2f RPM\n", to_rpm(vel));
```

---

#### 10. `getTemperature()` - ç²å–æº«åº¦
```cpp
Temperature getTemperature();
```

**è¿”å›å€¼**: é¦¬é”ç¾¤çµ„çš„å¹³å‡æº«åº¦

**ç¯„ä¾‹**:
```cpp
Temperature temp = motors.getTemperature();
if (to_celsius(temp) > 50.0) {
    printf("è­¦å‘Š: é¦¬é”éç†±! %.1fÂ°C\n", to_celsius(temp));
}
```

---

#### 11. `getCurrent()` - ç²å–é›»æµ
```cpp
Current getCurrent();
```

**è¿”å›å€¼**: é¦¬é”ç¾¤çµ„çš„ç¸½é›»æµ

**ç¯„ä¾‹**:
```cpp
Current current = motors.getCurrent();
printf("ç¸½é›»æµ: %.2f A\n", to_amp(current));
```

---

### ğŸ® å®Œæ•´ä½¿ç”¨ç¯„ä¾‹

```cpp
void example() {
    // å‰µå»ºé¦¬é”ç¾¤çµ„
    lemlib::MotorGroup left_motors({1, 2, 3}, 360_rpm);
    lemlib::MotorGroup right_motors({-8, -9, -10}, 360_rpm);
    
    // è¨­ç½®ç…è»Šæ¨¡å¼
    left_motors.setBrakeMode(lemlib::BrakeMode::BRAKE);
    right_motors.setBrakeMode(lemlib::BrakeMode::BRAKE);
    
    // æª¢æŸ¥é€£æ¥
    if (left_motors.isConnected() && right_motors.isConnected()) {
        printf("æ‰€æœ‰é¦¬é”å·²é€£æ¥\n");
        
        // å‰é€²
        left_motors.move(0.8);
        right_motors.move(0.8);
        pros::delay(1000);
        
        // åœæ­¢
        left_motors.brake();
        right_motors.brake();
        
        // æª¢æŸ¥æº«åº¦
        Temperature temp = left_motors.getTemperature();
        printf("å·¦å´é¦¬é”æº«åº¦: %.1fÂ°C\n", to_celsius(temp));
    }
}
```

---

## ğŸ“¡ æ„Ÿæ¸¬å™¨ API

### æ…£æ€§æ¸¬é‡å–®å…ƒ (IMU)

#### ğŸ“– æ¦‚è¿°
V5 Inertial Sensor æä¾›è§’åº¦ã€è§’é€Ÿåº¦å’ŒåŠ é€Ÿåº¦æ¸¬é‡ã€‚

#### ğŸ¯ å‰µå»º IMU

```cpp
// å‰µå»º IMU (åŸ è™Ÿ 1)
lemlib::V5InertialSensor imu(1);

// å¾ PROS IMU å‰µå»º
pros::Imu prosImu(1);
lemlib::V5InertialSensor imu = lemlib::V5InertialSensor::from_pros_imu(prosImu);
```

---

#### IMU æŒ‡ä»¤

#### 1. `calibrate()` - æ ¡æº–
```cpp
int calibrate();
```

æ ¡æº– IMUï¼Œéœ€è¦åœ¨éœæ­¢ç‹€æ…‹ä¸‹é€²è¡Œï¼Œé€šå¸¸éœ€è¦ 2-3 ç§’ã€‚

**è¿”å›å€¼**:
- `0`: æˆåŠŸé–‹å§‹æ ¡æº–
- `INT_MAX`: å¤±æ•—

**ç¯„ä¾‹**:
```cpp
void initialize() {
    lemlib::V5InertialSensor imu(1);
    
    printf("é–‹å§‹æ ¡æº– IMU...\n");
    imu.calibrate();
    pros::delay(3200);  // ç­‰å¾…æ ¡æº–å®Œæˆ
    
    if (imu.isCalibrated()) {
        printf("IMU æ ¡æº–å®Œæˆ\n");
    }
}
```

---

#### 2. `isCalibrated()` - æª¢æŸ¥æ˜¯å¦å·²æ ¡æº–
```cpp
int isCalibrated();
```

**è¿”å›å€¼**:
- `1`: å·²æ ¡æº–
- `0`: æœªæ ¡æº–

---

#### 3. `isCalibrating()` - æª¢æŸ¥æ˜¯å¦æ­£åœ¨æ ¡æº–
```cpp
int isCalibrating();
```

**ç¯„ä¾‹**:
```cpp
imu.calibrate();
while (imu.isCalibrating()) {
    printf("æ ¡æº–ä¸­...\n");
    pros::delay(100);
}
```

---

#### 4. `isConnected()` - æª¢æŸ¥é€£æ¥
```cpp
int isConnected();
```

---

#### 5. `getRotation()` - ç²å–æ—‹è½‰è§’åº¦
```cpp
Angle getRotation();
```

ç²å– IMU çš„ç„¡ç•Œæ—‹è½‰è§’åº¦ï¼ˆå¯ä»¥è¶…é 360 åº¦ï¼‰ã€‚

**è¿”å›å€¼**:
- `Angle`: è§’åº¦å€¼
- `INFINITY`: éŒ¯èª¤

**ç¯„ä¾‹**:
```cpp
Angle rotation = imu.getRotation();
printf("æ—‹è½‰è§’åº¦: %.2f åº¦\n", to_stDeg(rotation));

// æª¢æŸ¥æ˜¯å¦æ—‹è½‰è¶…é 360 åº¦
if (abs(to_stDeg(rotation)) > 360) {
    printf("å·²æ—‹è½‰è¶…éä¸€åœˆ\n");
}
```

---

#### 6. `getHeading()` - ç²å–èˆªå‘
```cpp
Angle getHeading();
```

ç²å– 0-360 åº¦ç¯„åœå…§çš„èˆªå‘è§’ã€‚

**ç¯„ä¾‹**:
```cpp
Angle heading = imu.getHeading();
printf("èˆªå‘: %.2f åº¦\n", to_stDeg(heading));
```

---

#### 7. `getAngularVelocity()` - ç²å–è§’é€Ÿåº¦
```cpp
AngularVelocity getAngularVelocity();
```

**ç¯„ä¾‹**:
```cpp
AngularVelocity vel = imu.getAngularVelocity();
printf("è§’é€Ÿåº¦: %.2f åº¦/ç§’\n", to_degps(vel));
```

---

#### 8. `getAcceleration()` - ç²å–åŠ é€Ÿåº¦
```cpp
units::Vector3D<Acceleration> getAcceleration();
```

**è¿”å›å€¼**: 3D åŠ é€Ÿåº¦å‘é‡ (x, y, z)

**ç¯„ä¾‹**:
```cpp
auto accel = imu.getAcceleration();
printf("åŠ é€Ÿåº¦ X: %.2f, Y: %.2f, Z: %.2f\n", 
       to_mps2(accel.x), 
       to_mps2(accel.y), 
       to_mps2(accel.z));
```

---

#### 9. `setRotation()` - è¨­ç½®æ—‹è½‰è§’åº¦
```cpp
int setRotation(Angle rotation);
```

è¨­ç½® IMU çš„åƒè€ƒæ—‹è½‰è§’åº¦ã€‚

**ç¯„ä¾‹**:
```cpp
imu.setRotation(0_stDeg);     // é‡ç½®ç‚º 0 åº¦
imu.setRotation(90_stDeg);    // è¨­ç½®ç‚º 90 åº¦
```

---

### ç·¨ç¢¼å™¨ (Encoder)

ç·¨ç¢¼å™¨æ˜¯è¿½è¹¤æ—‹è½‰çš„åŸºç¤é¡ï¼ŒMotorGroup ç¹¼æ‰¿è‡ªé€™å€‹é¡ã€‚

#### ä¸»è¦æ–¹æ³•

```cpp
// ç²å–è§’åº¦
Angle angle = encoder.getAngle();

// è¨­ç½®è§’åº¦
encoder.setAngle(0_stDeg);

// ç²å–é€Ÿåº¦
AngularVelocity vel = encoder.getVelocity();

// æª¢æŸ¥é€£æ¥
if (encoder.isConnected()) {
    // ...
}
```

---

### è¿½è¹¤è¼ª (TrackingWheel)

#### ğŸ“– æ¦‚è¿°
è¿½è¹¤è¼ªç”¨æ–¼é‡Œç¨‹è¨ˆç³»çµ±ï¼Œæ¸¬é‡æ©Ÿå™¨äººçš„ä½ç§»ã€‚

#### ğŸ¯ å‰µå»ºè¿½è¹¤è¼ª

```cpp
// ä½¿ç”¨ç·¨ç¢¼å™¨æŒ‡é‡å‰µå»º
lemlib::V5RotationSensor encoder(3, true);  // åŸ  3, åè½‰
lemlib::TrackingWheel wheel(&encoder, 2.75_in, -3_in);

// ä½¿ç”¨ ADI åŸ å‰µå»º
lemlib::TrackingWheel vertical('E', 'F', true, 2.75_in, 13.25_cm);
// ADI åŸ  E, F
// åè½‰
// è¼ªå¾‘ 2.75 è‹±å¯¸
// åç§» 13.25 å˜ç±³

// å¸¶é½’è¼ªæ¯”çš„å‰µå»º
lemlib::TrackingWheel wheel('A', 'B', false, 2.75_in, 0_in, 36.0/60.0);
// é½’è¼ªæ¯” = é©…å‹•é½’è¼ª / å¾å‹•é½’è¼ª = 36/60
```

**åƒæ•¸èªªæ˜**:
- **ç·¨ç¢¼å™¨åŸ **: ADI åŸ  ('A' - 'H') æˆ–æ™ºèƒ½åŸ  (1-21)
- **åè½‰**: `true` åè½‰è®€æ•¸æ–¹å‘
- **è¼ªå¾‘**: è¿½è¹¤è¼ªçš„ç›´å¾‘
- **åç§»**: è¿½è¹¤è¼ªè·é›¢æ©Ÿå™¨äººæ—‹è½‰ä¸­å¿ƒçš„è·é›¢
  - æ­£å€¼: å³å´/å‰å´
  - è² å€¼: å·¦å´/å¾Œå´
- **é½’è¼ªæ¯”**: é©…å‹•é½’è¼ª/å¾å‹•é½’è¼ªï¼ˆé è¨­ 1ï¼‰

---

#### è¿½è¹¤è¼ªæ–¹æ³•

```cpp
// ç²å–ä½ç§»
Length distance = trackingWheel.getDistanceTraveled();
printf("ç§»å‹•è·é›¢: %.2f è‹±å¯¸\n", to_in(distance));

// é‡ç½®ä½ç§»
trackingWheel.reset();

// ç²å–é€Ÿåº¦
LinearVelocity vel = trackingWheel.getVelocity();
printf("é€Ÿåº¦: %.2f è‹±å¯¸/ç§’\n", to_inps(vel));
```

---

## ğŸ“ å–®ä½ç³»çµ±

### ğŸ¯ æ”¯æ´çš„å–®ä½

#### é•·åº¦ (Length)
```cpp
24_in          // è‹±å¯¸ (inches)
30_cm          // å˜ç±³ (centimeters)
1.5_m          // ç±³ (meters)
12_ft          // è‹±å°º (feet)
```

**è½‰æ›å‡½æ•¸**:
```cpp
Length distance = 24_in;
Number inches = to_in(distance);      // è½‰ç‚ºè‹±å¯¸
Number cm = to_cm(distance);          // è½‰ç‚ºå˜ç±³
Number meters = to_m(distance);       // è½‰ç‚ºç±³
```

---

#### è§’åº¦ (Angle)
```cpp
90_deg         // åº¦ (degrees)
90_cDeg        // å˜åº¦ (centidegrees, 1 cDeg = 0.01 åº¦)
90_stDeg       // æ¨™æº–åº¦ (standard degrees)
1.57_rad       // å¼§åº¦ (radians)
1.57_stRad     // æ¨™æº–å¼§åº¦
```

**è½‰æ›å‡½æ•¸**:
```cpp
Angle angle = 90_cDeg;
Number degrees = to_cDeg(angle);      // è½‰ç‚ºå˜åº¦
Number stdDeg = to_stDeg(angle);      // è½‰ç‚ºæ¨™æº–åº¦
Number radians = to_stRad(angle);     // è½‰ç‚ºå¼§åº¦
```

**æ³¨æ„**: `cDeg` (å˜åº¦) æ˜¯ LemLib çš„æ¨™æº–è§’åº¦å–®ä½
- `90_cDeg` = `0.9_deg` = `0.9 åº¦`
- `9000_cDeg` = `90_deg` = `90 åº¦`

---

#### æ™‚é–“ (Time)
```cpp
1_sec          // ç§’
500_msec       // æ¯«ç§’
1.5_min        // åˆ†é˜
```

**è½‰æ›å‡½æ•¸**:
```cpp
Time duration = 1.5_sec;
Number seconds = to_sec(duration);
Number msec = to_msec(duration);
```

---

#### é€Ÿåº¦å–®ä½

**è§’é€Ÿåº¦ (AngularVelocity)**:
```cpp
360_rpm        // è½‰/åˆ†é˜ (rotations per minute)
180_degps      // åº¦/ç§’ (degrees per second)
```

**ç·šé€Ÿåº¦ (LinearVelocity)**:
```cpp
12_inps        // è‹±å¯¸/ç§’
30_cmps        // å˜ç±³/ç§’
1_mps          // ç±³/ç§’
```

---

#### æº«åº¦ (Temperature)
```cpp
Temperature temp = motors.getTemperature();
Number celsius = to_celsius(temp);
Number fahrenheit = to_fahrenheit(temp);
```

---

#### é›»æµ (Current)
```cpp
Current current = motors.getCurrent();
Number amps = to_amp(current);
Number milliamps = to_mamp(current);
```

---

### ğŸ§® å–®ä½é‹ç®—

#### åŸºæœ¬é‹ç®—
```cpp
// åŠ æ³•
Length total = 12_in + 6_in;           // 18 è‹±å¯¸

// æ¸›æ³•
Length diff = 24_in - 6_in;            // 18 è‹±å¯¸

// ä¹˜æ³• (æ•¸å€¼ Ã— å–®ä½)
Length doubled = 12_in * 2;            // 24 è‹±å¯¸
Length area = 12_in * 2.5;             // 30 è‹±å¯¸

// é™¤æ³•
Number ratio = 24_in / 12_in;          // 2.0 (ç„¡å–®ä½)
Length half = 24_in / 2;               // 12 è‹±å¯¸
```

---

#### æ¯”è¼ƒé‹ç®—
```cpp
Length a = 24_in;
Length b = 12_in;

if (a > b) printf("a å¤§æ–¼ b\n");
if (a >= b) printf("a å¤§æ–¼ç­‰æ–¼ b\n");
if (a == b) printf("a ç­‰æ–¼ b\n");
if (a != b) printf("a ä¸ç­‰æ–¼ b\n");
if (a < b) printf("a å°æ–¼ b\n");
if (a <= b) printf("a å°æ–¼ç­‰æ–¼ b\n");
```

---

#### æ•¸å­¸å‡½æ•¸
```cpp
// çµ•å°å€¼
Length distance = abs(-12_in);         // 12 è‹±å¯¸

// æœ€å¤§å€¼/æœ€å°å€¼
Length max_dist = max(12_in, 24_in);   // 24 è‹±å¯¸
Length min_dist = min(12_in, 24_in);   // 12 è‹±å¯¸

// é™åˆ¶ç¯„åœ
Length clamped = clamp(15_in, 10_in, 20_in);  // 15 è‹±å¯¸
Length clamped2 = clamp(5_in, 10_in, 20_in);  // 10 è‹±å¯¸
Length clamped3 = clamp(25_in, 10_in, 20_in); // 20 è‹±å¯¸

// ç¬¦è™Ÿå‡½æ•¸
Number sign1 = sgn(12_in);             // 1
Number sign2 = sgn(-12_in);            // -1
Number sign3 = sgn(0_in);              // 0
```

---

### ğŸ“ ä½ç½®èˆ‡å§¿æ…‹

#### Pose (å§¿æ…‹)
```cpp
// å‰µå»ºå§¿æ…‹
units::Pose pose = {24_in, 12_in, 90_cDeg};
// x = 24 è‹±å¯¸
// y = 12 è‹±å¯¸
// orientation = 90 å˜åº¦ = 0.9 åº¦

// è¨ªå•æˆå“¡
Length x = pose.x;
Length y = pose.y;
Angle theta = pose.orientation;

// è¨ˆç®—è·é›¢
units::V2Position target = {48_in, 24_in};
Length distance = pose.distanceTo(target);

// è¨ˆç®—è§’åº¦
Angle angleToTarget = pose.angleTo(target);
```

---

#### V2Position (2D ä½ç½®)
```cpp
// å‰µå»ºä½ç½®
units::V2Position pos = {24_in, 12_in};

// å¾æ¥µåº§æ¨™å‰µå»º
units::V2Position pos2 = units::V2Position::fromPolar(90_cDeg, 12_in);
// è§’åº¦ 90 å˜åº¦ï¼Œè·é›¢ 12 è‹±å¯¸

// å‘é‡é‹ç®—
units::V2Position a = {10_in, 5_in};
units::V2Position b = {5_in, 3_in};
units::V2Position sum = a + b;         // {15_in, 8_in}
units::V2Position diff = a - b;        // {5_in, 2_in}
units::V2Position scaled = a * 2;      // {20_in, 10_in}
```

---

## ğŸ§® æ•¸å­¸å·¥å…·å‡½æ•¸

### ğŸ“– è§’åº¦è¨ˆç®—

#### 1. `angleError()` - è¨ˆç®—è§’åº¦èª¤å·®
```cpp
Angle angleError(Angle target, Angle position, 
                std::optional<AngularDirection> direction = std::nullopt);
```

è¨ˆç®—å¾ç•¶å‰è§’åº¦åˆ°ç›®æ¨™è§’åº¦çš„æœ€çŸ­èª¤å·®ã€‚

**åƒæ•¸**:
- `target`: ç›®æ¨™è§’åº¦
- `position`: ç•¶å‰è§’åº¦
- `direction`: å¼·åˆ¶æ–¹å‘ (å¯é¸)
  - `AngularDirection::CW_CLOCKWISE` - é †æ™‚é‡
  - `AngularDirection::CCW_COUNTERCLOCKWISE` - é€†æ™‚é‡
  - `std::nullopt` - è‡ªå‹•é¸æ“‡æœ€çŸ­è·¯å¾‘

**ç¯„ä¾‹**:
```cpp
// è‡ªå‹•é¸æ“‡æœ€çŸ­è·¯å¾‘
Angle error1 = angleError(90_cDeg, 10_cDeg);
// error1 = 80 cDeg (é€†æ™‚é‡)

Angle error2 = angleError(10_cDeg, 350_cDeg);
// error2 = 20 cDeg (é †æ™‚é‡)

// å¼·åˆ¶é †æ™‚é‡
Angle error3 = angleError(10_cDeg, 350_cDeg, AngularDirection::CW_CLOCKWISE);
// error3 = 20 cDeg

// å¼·åˆ¶é€†æ™‚é‡
Angle error4 = angleError(10_cDeg, 350_cDeg, AngularDirection::CCW_COUNTERCLOCKWISE);
// error4 = -340 cDeg
```

---

### ğŸšï¸ é€Ÿåº¦æ§åˆ¶

#### 2. `slew()` - æ–œç‡é™åˆ¶
```cpp
Number slew(Number target, Number current, Number maxChangeRate, Time deltaTime,
           SlewDirection restrictDirection = SlewDirection::ALL);
```

é™åˆ¶æ•¸å€¼è®ŠåŒ–é€Ÿåº¦ï¼Œç”¨æ–¼å¹³æ»‘åŠ é€Ÿ/æ¸›é€Ÿã€‚

**åƒæ•¸**:
- `target`: ç›®æ¨™å€¼
- `current`: ç•¶å‰å€¼
- `maxChangeRate`: æœ€å¤§è®ŠåŒ–ç‡ (å–®ä½/ç§’)
- `deltaTime`: æ™‚é–“é–“éš”
- `restrictDirection`: é™åˆ¶æ–¹å‘
  - `SlewDirection::ALL` - é›™å‘é™åˆ¶
  - `SlewDirection::INCREASING` - åªé™åˆ¶å¢åŠ 
  - `SlewDirection::DECREASING` - åªé™åˆ¶æ¸›å°‘

**ç¯„ä¾‹**:
```cpp
Number current = 0;
Number target = 1.0;
Time dt = 10_msec;  // 10 æ¯«ç§’

// æœ€å¤§è®ŠåŒ–ç‡ 10/ç§’
current = slew(target, current, 10, dt);
// current = 0.1 (å› ç‚º 10 * 0.01 = 0.1)

// ä¸‹ä¸€æ¬¡è¿­ä»£
current = slew(target, current, 10, dt);
// current = 0.2

// åªåœ¨å¢åŠ æ™‚é™åˆ¶
current = slew(1.0, 0.5, 10, dt, SlewDirection::INCREASING);
// current = 0.6

current = slew(0.0, 0.5, 10, dt, SlewDirection::INCREASING);
// current = 0.0 (ç«‹å³é™ä½ï¼Œä¸å—é™åˆ¶)
```

---

#### 3. `constrainPower()` - åŠŸç‡é™åˆ¶
```cpp
Number constrainPower(Number power, Number max, Number min);
```

é™åˆ¶åŠŸç‡å€¼çš„çµ•å°å€¼ç¯„åœï¼ŒåŒæ™‚ä¿æŒç¬¦è™Ÿã€‚

**åƒæ•¸**:
- `power`: è¼¸å…¥åŠŸç‡
- `max`: æœ€å¤§çµ•å°å€¼
- `min`: æœ€å°çµ•å°å€¼

**ç¯„ä¾‹**:
```cpp
Number p1 = constrainPower(0.8, 1.0, 0.3);
// p1 = 0.8 (åœ¨ç¯„åœå…§)

Number p2 = constrainPower(0.1, 1.0, 0.3);
// p2 = 0.3 (å°æ–¼æœ€å°å€¼ï¼Œæå‡åˆ° 0.3)

Number p3 = constrainPower(1.5, 1.0, 0.3);
// p3 = 1.0 (è¶…éæœ€å¤§å€¼ï¼Œé™åˆ¶åˆ° 1.0)

Number p4 = constrainPower(-0.1, 1.0, 0.3);
// p4 = -0.3 (ä¿æŒè² è™Ÿ)

Number p5 = constrainPower(-1.5, 1.0, 0.3);
// p5 = -1.0 (ä¿æŒè² è™Ÿ)
```

---

#### 4. `desaturate()` - å»é£½å’Œ
```cpp
DriveOutputs desaturate(Number lateralOutput, Number angularOutput);
```

è¨ˆç®—å·¦å³è¼ªè¼¸å‡ºï¼Œç¢ºä¿ä¸è¶…é Â±1.0 ç¯„åœã€‚

**è¿”å›å€¼**:
```cpp
struct DriveOutputs {
    Number left;   // å·¦è¼ªè¼¸å‡º
    Number right;  // å³è¼ªè¼¸å‡º
};
```

**ç¯„ä¾‹**:
```cpp
// æ­£å¸¸æƒ…æ³
auto out1 = desaturate(0.6, 0.2);
// out1.left = 0.8, out1.right = 0.4

// éœ€è¦ç¸®æ”¾çš„æƒ…æ³
auto out2 = desaturate(0.8, 0.5);
// åŸå§‹: left = 1.3, right = 0.3
// ç¸®æ”¾å¾Œ: left = 1.0, right = 0.23

// ä½¿ç”¨ç¯„ä¾‹
auto outputs = desaturate(lateralPower, angularPower);
left_motors.move(outputs.left);
right_motors.move(outputs.right);
```

---

### ğŸ“ å¹¾ä½•è¨ˆç®—

#### 5. `getSignedTangentArcCurvature()` - è¨ˆç®—æ›²ç‡
```cpp
Curvature getSignedTangentArcCurvature(units::Pose start, units::V2Position end);
```

è¨ˆç®—å¾èµ·é»åˆ°çµ‚é»çš„åˆ‡ç·šå¼§æ›²ç‡ï¼ˆç”¨æ–¼è·¯å¾‘è·Ÿéš¨ï¼‰ã€‚

**ç¯„ä¾‹**:
```cpp
units::Pose currentPose = {0_in, 0_in, 0_cDeg};
units::V2Position targetPoint = {24_in, 12_in};

Curvature curvature = getSignedTangentArcCurvature(currentPose, targetPoint);
```

---

## ğŸ® é‹å‹•æ§åˆ¶æŒ‡ä»¤

### 1. moveToPoint - ç§»å‹•åˆ°é»

```cpp
void moveToPoint(units::V2Position target, Time timeout, 
                MoveToPointParams params = {}, 
                MoveToPointSettings settings = {});
```

å°‡æ©Ÿå™¨äººç§»å‹•åˆ°æŒ‡å®šçš„ (x, y) åº§æ¨™ã€‚

**åƒæ•¸**:
```cpp
struct MoveToPointParams {
    bool reversed = false;              // æ˜¯å¦å€’è»Š
    Number maxLateralSpeed = 1;         // æœ€å¤§æ©«å‘é€Ÿåº¦ (0-1)
    Number minLateralSpeed = 0;         // æœ€å°æ©«å‘é€Ÿåº¦
    Number maxAngularSpeed = 1;         // æœ€å¤§è§’å‘é€Ÿåº¦ (0-1)
    Number lateralSlew = lateral_slew;  // æ©«å‘æ–œç‡é™åˆ¶
    Number angularSlew = angular_slew;  // è§’å‘æ–œç‡é™åˆ¶
    Length earlyExitRange = 0_in;       // æå‰é€€å‡ºç¯„åœ
};
```

**ç¯„ä¾‹**:
```cpp
// åŸºæœ¬ä½¿ç”¨ - ç§»å‹•åˆ° (24, 24) è‹±å¯¸
lemlib::moveToPoint({24_in, 24_in}, 5_sec, {}, {});

// è‡ªå®šç¾©åƒæ•¸
lemlib::MoveToPointParams params;
params.maxLateralSpeed = 0.8;      // æœ€å¤§ 80% é€Ÿåº¦
params.minLateralSpeed = 0.3;      // æœ€å° 30% é€Ÿåº¦
params.maxAngularSpeed = 0.6;      // è½‰å‘ 60% é€Ÿåº¦
params.reversed = false;           // æ­£å‘ç§»å‹•

lemlib::moveToPoint({48_in, 12_in}, 8_sec, params, {});

// å€’è»Šç§»å‹•
params.reversed = true;
lemlib::moveToPoint({0_in, 0_in}, 5_sec, params, {});
```

---

### 2. moveToPose - ç§»å‹•åˆ°å§¿æ…‹

```cpp
void moveToPose(units::Pose target, Time timeout,
               MoveToPoseParams params = {},
               MoveToPoseSettings settings = {});
```

å°‡æ©Ÿå™¨äººç§»å‹•åˆ°æŒ‡å®šçš„ä½ç½®å’Œæ–¹å‘ã€‚

**åƒæ•¸**:
```cpp
struct MoveToPoseParams {
    bool reversed = false;
    Number maxLateralSpeed = 1;
    Number minLateralSpeed = 0;
    Number maxAngularSpeed = 1;
    Number lateralSlew = lateral_slew;
    Number angularSlew = angular_slew;
    Number lead = 0.6;                  // å…ˆå°ä¿‚æ•¸
    Length earlyExitRange = 0_in;
    Number driftCompensation = 0;       // æ¼‚ç§»è£œå„Ÿ
};
```

**ç¯„ä¾‹**:
```cpp
// ç§»å‹•åˆ° (24, 24) ä¸¦é¢å‘ 90 åº¦
lemlib::moveToPose({24_in, 24_in, 90_cDeg}, 10_sec, {}, {});

// è‡ªå®šç¾©åƒæ•¸
lemlib::MoveToPoseParams params;
params.maxLateralSpeed = 0.7;
params.lead = 0.5;                // æ›´æ¿€é€²çš„è½‰å½
params.driftCompensation = 0.1;   // è£œå„Ÿå´æ»‘

lemlib::moveToPose({48_in, 36_in, 180_cDeg}, 12_sec, params, {});
```

---

### 3. turnTo - è½‰å‘

```cpp
void turnTo(std::variant<Angle, V2Position> target, Time timeout,
           TurnToParams params = {},
           TurnToSettings settings = {});
```

è½‰å‘æŒ‡å®šè§’åº¦æˆ–é¢å‘æŒ‡å®šé»ã€‚

**åƒæ•¸**:
```cpp
struct TurnToParams {
    Number maxSpeed = 1;                           // æœ€å¤§è½‰é€Ÿ
    Number minSpeed = 0;                           // æœ€å°è½‰é€Ÿ
    Number slew = angular_slew;                    // æ–œç‡é™åˆ¶
    std::optional<AngularDirection> direction;     // è½‰å‘æ–¹å‘
    std::optional<LockedSide> lockedSide;         // é–å®šå´
    Length earlyExitRange = 0_in;
};
```

**ç¯„ä¾‹**:
```cpp
// è½‰åˆ° 90 åº¦
lemlib::turnTo(90_cDeg, 3_sec, {}, {});

// é¢å‘é» (24, 24)
lemlib::turnTo({24_in, 24_in}, 3_sec, {}, {});

// å¼·åˆ¶é †æ™‚é‡è½‰å‘
lemlib::TurnToParams params;
params.direction = lemlib::AngularDirection::CW_CLOCKWISE;
lemlib::turnTo(180_cDeg, 3_sec, params, {});

// Pivot turn - é–å®šå·¦å´
params.lockedSide = lemlib::TurnToParams::LockedSide::LEFT;
lemlib::turnTo(90_cDeg, 3_sec, params, {});
```

---

### 4. follow - è·¯å¾‘è·Ÿéš¨

```cpp
void follow(const asset& path, Length lookaheadDistance, Time timeout,
           FollowParams params = {},
           FollowSettings settings = {});
```

æ²¿è‘—é å®šç¾©è·¯å¾‘ç§»å‹•ï¼ˆPure Pursuit ç®—æ³•ï¼‰ã€‚

**åƒæ•¸**:
```cpp
struct FollowParams {
    bool reversed = false;              // å€’è»Šè·Ÿéš¨
    Number lateralSlew = lateral_slew;  // æ–œç‡é™åˆ¶
};
```

**ç¯„ä¾‹**:
```cpp
// ä½¿ç”¨ ASSET åŠ è¼‰è·¯å¾‘
ASSET(my_path);

// åŸºæœ¬è·Ÿéš¨
lemlib::follow(my_path, 8_in, 20_sec, {}, {});

// å€’è»Šè·Ÿéš¨
lemlib::FollowParams params;
params.reversed = true;
lemlib::follow(my_path, 6_in, 20_sec, params, {});

// ä¸åŒå‰ç»è·é›¢
lemlib::follow(my_path, 12_in, 25_sec, {}, {});  // é«˜é€Ÿï¼Œå¤§å‰ç»
lemlib::follow(my_path, 4_in, 15_sec, {}, {});   // ä½é€Ÿï¼Œå°å‰ç»
```

**è·¯å¾‘æ–‡ä»¶æ ¼å¼** (static/path.txt):
```
x1, y1, speed1
x2, y2, speed2
x3, y3, speed3
endData
```

---

## ğŸ›ï¸ PID æ§åˆ¶å™¨

### ğŸ“– å‰µå»º PID

```cpp
// åŸºæœ¬å‰µå»º
lemlib::PID pid(kP, kI, kD);

// å¸¶ windup å’Œ sign flip reset
lemlib::PID pid(kP, kI, kD, windupRange, signFlipReset);

// ä½¿ç”¨ Gains çµæ§‹
lemlib::Gains gains = {kP, kI, kD};
lemlib::PID pid(gains);
```

**ç¯„ä¾‹**:
```cpp
// ç°¡å–®çš„ P æ§åˆ¶å™¨
lemlib::PID lateral_pid(0.5, 0, 0);

// PD æ§åˆ¶å™¨
lemlib::PID angular_pid(0.08, 0, 0.02);

// PID æ§åˆ¶å™¨ï¼Œå¸¶ç©åˆ† windup é˜²æ­¢
lemlib::PID full_pid(1.0, 0.1, 0.05, 10, true);
// kP=1.0, kI=0.1, kD=0.05
// windupRange=10 (èª¤å·®è¶…é 10 æ™‚é‡ç½®ç©åˆ†)
// signFlipReset=true (èª¤å·®è®Šè™Ÿæ™‚é‡ç½®ç©åˆ†)
```

---

### ğŸ® PID æ–¹æ³•

#### 1. `update()` - æ›´æ–° PID
```cpp
Number update(Number error);
```

è¼¸å…¥èª¤å·®ï¼Œè¿”å›æ§åˆ¶è¼¸å‡ºã€‚

**ç¯„ä¾‹**:
```cpp
lemlib::PID pid(0.5, 0.1, 0.05);

// åœ¨å¾ªç’°ä¸­ä½¿ç”¨
while (true) {
    // è¨ˆç®—èª¤å·®
    Number error = target - current;
    
    // ç²å– PID è¼¸å‡º
    Number output = pid.update(error);
    
    // æ‡‰ç”¨è¼¸å‡º
    motors.move(output);
    
    pros::delay(10);
}
```

---

#### 2. `reset()` - é‡ç½® PID
```cpp
void reset();
```

æ¸…é™¤ PID çš„ç©åˆ†å’Œå¾®åˆ†é …ã€‚

**ç¯„ä¾‹**:
```cpp
pid.reset();  // é–‹å§‹æ–°çš„é‹å‹•å‰é‡ç½®
```

---

#### 3. `setGains()` / `getGains()` - å¢ç›Šè¨­ç½®
```cpp
void setGains(const Gains& gains);
Gains getGains();
```

**ç¯„ä¾‹**:
```cpp
// å‹•æ…‹èª¿æ•´å¢ç›Š
lemlib::Gains newGains = {0.8, 0.15, 0.03};
pid.setGains(newGains);

// ç²å–ç•¶å‰å¢ç›Š
lemlib::Gains current = pid.getGains();
printf("kP: %.2f, kI: %.2f, kD: %.2f\n", 
       current.kP, current.kI, current.kD);
```

---

## ğŸ“ é‡Œç¨‹è¨ˆç³»çµ±

### ğŸ“– å‰µå»ºé‡Œç¨‹è¨ˆ

```cpp
// å‰µå»ºè¿½è¹¤è¼ªé‡Œç¨‹è¨ˆ
lemlib::TrackingWheelOdometry odom(
    {&imu},                    // IMU åˆ—è¡¨
    {&vertical_tracker},       // å‚ç›´è¿½è¹¤è¼ªåˆ—è¡¨
    {&horizontal_tracker}      // æ°´å¹³è¿½è¹¤è¼ªåˆ—è¡¨
);
```

---

### ğŸ® é‡Œç¨‹è¨ˆæ–¹æ³•

#### 1. `startTask()` - å•Ÿå‹•è¿½è¹¤
```cpp
void startTask(Time period = 10_msec);
```

å•Ÿå‹•èƒŒæ™¯ä»»å‹™æ›´æ–°ä½ç½®ã€‚

**ç¯„ä¾‹**:
```cpp
void initialize() {
    imu.calibrate();
    pros::delay(3200);
    
    // å•Ÿå‹•é‡Œç¨‹è¨ˆè¿½è¹¤
    odom.startTask();  // é è¨­ 10ms æ›´æ–°é€±æœŸ
    // æˆ–è‡ªå®šç¾©é€±æœŸ
    odom.startTask(5_msec);  // 5ms æ›´æ–°é€±æœŸ
}
```

---

#### 2. `stopTask()` - åœæ­¢è¿½è¹¤
```cpp
void stopTask();
```

---

#### 3. `setPose()` - è¨­ç½®ä½ç½®
```cpp
void setPose(units::Pose pose);
```

**ç¯„ä¾‹**:
```cpp
// è¨­ç½®èµ·å§‹ä½ç½®
odom.setPose({0_in, 0_in, 0_cDeg});

// è¨­ç½®åˆ°ç‰¹å®šä½ç½®
odom.setPose({24_in, 12_in, 90_cDeg});
```

---

#### 4. `getPose()` - ç²å–ä½ç½®
```cpp
units::Pose getPose();
```

**ç¯„ä¾‹**:
```cpp
// ç²å–ç•¶å‰ä½ç½®
units::Pose pose = odom.getPose();
printf("ä½ç½®: X=%.2f, Y=%.2f, Î¸=%.2f\n",
       to_in(pose.x),
       to_in(pose.y),
       to_cDeg(pose.orientation));

// åœ¨ LCD ä¸Šé¡¯ç¤º
pros::Task([] {
    while (true) {
        auto p = odom.getPose();
        pros::lcd::print(0, "X: %.2f in", to_in(p.x));
        pros::lcd::print(1, "Y: %.2f in", to_in(p.y));
        pros::lcd::print(2, "Î¸: %.2f deg", to_cDeg(p.orientation));
        pros::delay(50);
    }
});
```

---

## ğŸ’¡ å¸¸ç”¨ç¨‹å¼ç¢¼ç¯„ä¾‹

### ğŸš€ åˆå§‹åŒ–åºåˆ—

```cpp
void initialize() {
    // 1. è¨­ç½®æ—¥èªŒç´šåˆ¥
    terminal.setLoggingLevel(logger::Level::DEBUG);
    
    // 2. åˆå§‹åŒ– LCD
    pros::lcd::initialize();
    pros::lcd::print(0, "Initializing...");
    
    // 3. æ ¡æº– IMU
    pros::lcd::print(1, "Calibrating IMU...");
    imu.calibrate();
    pros::delay(3200);  // ç­‰å¾…æ ¡æº–å®Œæˆ
    
    if (imu.isCalibrated()) {
        pros::lcd::print(1, "IMU Ready");
    }
    
    // 4. å•Ÿå‹•é‡Œç¨‹è¨ˆ
    odom.startTask();
    pros::delay(100);
    
    // 5. è¨­ç½®é¦¬é”ç…è»Šæ¨¡å¼
    left_motors.setBrakeMode(lemlib::BrakeMode::BRAKE);
    right_motors.setBrakeMode(lemlib::BrakeMode::BRAKE);
    
    // 6. å‰µå»ºä½ç½®é¡¯ç¤ºä»»å‹™
    pros::Task([] {
        while (true) {
            auto p = odom.getPose();
            pros::lcd::print(3, "X: %.1f Y: %.1f", to_in(p.x), to_in(p.y));
            pros::lcd::print(4, "Heading: %.1f deg", to_cDeg(p.orientation));
            pros::delay(50);
        }
    });
    
    pros::lcd::print(2, "Init Complete!");
}
```

---

### ğŸ¯ è‡ªä¸»ç¨‹åºç¯„ä¾‹

```cpp
void autonomous() {
    // è¨­ç½®èµ·å§‹ä½ç½®
    odom.setPose({0_in, 0_in, 0_cDeg});
    pros::delay(100);
    
    // 1. ç§»å‹•åˆ°ç¬¬ä¸€å€‹é»
    lemlib::moveToPoint({24_in, 0_in}, 3_sec, {}, {});
    pros::delay(500);
    
    // 2. è½‰å‘ 90 åº¦
    lemlib::turnTo(90_cDeg, 2_sec, {}, {});
    pros::delay(500);
    
    // 3. ç§»å‹•åˆ°ç¬¬äºŒå€‹é»
    lemlib::moveToPoint({24_in, 24_in}, 3_sec, {}, {});
    pros::delay(500);
    
    // 4. ç§»å‹•åˆ°æœ€çµ‚å§¿æ…‹
    lemlib::moveToPose({0_in, 24_in, 180_cDeg}, 5_sec, {}, {});
}
```

---

### ğŸ® æ‰‹å‹•æ§åˆ¶ç¯„ä¾‹

```cpp
void opcontrol() {
    pros::Controller controller(pros::E_CONTROLLER_MASTER);
    
    while (true) {
        // ç²å–æ–æ¡¿è¼¸å…¥
        int forward = controller.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_Y);
        int turn = controller.get_analog(pros::E_CONTROLLER_ANALOG_RIGHT_X);
        
        // è¨ˆç®—å·¦å³è¼ªåŠŸç‡ (-127 åˆ° 127)
        int left_power = forward + turn;
        int right_power = forward - turn;
        
        // è½‰æ›ç‚º -1.0 åˆ° 1.0
        Number left = left_power / 127.0;
        Number right = right_power / 127.0;
        
        // ç§»å‹•é¦¬é”
        left_motors.move(left);
        right_motors.move(right);
        
        // æŒ‰éˆ•æ§åˆ¶
        if (controller.get_digital(pros::E_CONTROLLER_DIGITAL_A)) {
            // A éµ - åŸ·è¡ŒæŸå€‹å‹•ä½œ
            left_motors.move(0.5);
            right_motors.move(0.5);
        }
        
        pros::delay(20);
    }
}
```

---

### ğŸ” æ„Ÿæ¸¬å™¨ç›£æ§ç¯„ä¾‹

```cpp
void opcontrol() {
    while (true) {
        // ç›£æ§é¦¬é”æº«åº¦
        Temperature left_temp = left_motors.getTemperature();
        Temperature right_temp = right_motors.getTemperature();
        
        if (to_celsius(left_temp) > 55.0) {
            pros::lcd::print(5, "WARNING: Left motor hot!");
            left_motors.move(0);  // åœæ­¢éç†±çš„é¦¬é”
        }
        
        // ç›£æ§é¦¬é”é›»æµ
        Current left_current = left_motors.getCurrent();
        Current right_current = right_motors.getCurrent();
        
        pros::lcd::print(6, "Current: L=%.1fA R=%.1fA",
                        to_amp(left_current),
                        to_amp(right_current));
        
        // ç›£æ§ IMU
        if (imu.isConnected()) {
            Angle heading = imu.getHeading();
            pros::lcd::print(7, "Heading: %.1f deg", to_stDeg(heading));
        } else {
            pros::lcd::print(7, "IMU Disconnected!");
        }
        
        pros::delay(100);
    }
}
```

---

### ğŸ›¡ï¸ éŒ¯èª¤è™•ç†ç¯„ä¾‹

```cpp
void initialize() {
    // æª¢æŸ¥é¦¬é”é€£æ¥
    if (!left_motors.isConnected()) {
        pros::lcd::print(0, "ERROR: Left motors!");
        return;
    }
    
    if (!right_motors.isConnected()) {
        pros::lcd::print(0, "ERROR: Right motors!");
        return;
    }
    
    // æª¢æŸ¥ IMU é€£æ¥
    if (!imu.isConnected()) {
        pros::lcd::print(0, "ERROR: IMU not found!");
        return;
    }
    
    // æ ¡æº– IMU å¸¶è¶…æ™‚
    imu.calibrate();
    int timeout = 0;
    while (imu.isCalibrating() && timeout < 4000) {
        pros::delay(100);
        timeout += 100;
    }
    
    if (!imu.isCalibrated()) {
        pros::lcd::print(0, "ERROR: IMU calibration failed!");
        return;
    }
    
    pros::lcd::print(0, "All systems ready!");
}
```

---

### ğŸ“Š æ•¸æ“šè¨˜éŒ„ç¯„ä¾‹

```cpp
void autonomous() {
    // è¨˜éŒ„è»Œè·¡
    std::vector<units::Pose> trajectory;
    
    pros::Task recorder([] {
        while (true) {
            trajectory.push_back(odom.getPose());
            pros::delay(100);  // æ¯ 100ms è¨˜éŒ„ä¸€æ¬¡
        }
    });
    
    // åŸ·è¡Œè‡ªä¸»ç¨‹åº
    lemlib::moveToPoint({24_in, 24_in}, 5_sec, {}, {});
    
    // åœæ­¢è¨˜éŒ„
    recorder.remove();
    
    // è¼¸å‡ºè»Œè·¡
    printf("Recorded %d points:\n", trajectory.size());
    for (const auto& pose : trajectory) {
        printf("%.2f, %.2f, %.2f\n",
               to_in(pose.x),
               to_in(pose.y),
               to_cDeg(pose.orientation));
    }
}
```

---

## ğŸ“š å¿«é€Ÿåƒè€ƒè¡¨

### é¦¬é”æ§åˆ¶

| åŠŸèƒ½ | æŒ‡ä»¤ | ç¯„ä¾‹ |
|------|------|------|
| æŒ‰åŠŸç‡ç§»å‹• | `move(percent)` | `motors.move(0.8)` |
| æŒ‰é€Ÿåº¦ç§»å‹• | `moveVelocity(vel)` | `motors.moveVelocity(180_degps)` |
| ç…è»Š | `brake()` | `motors.brake()` |
| è¨­ç½®ç…è»Šæ¨¡å¼ | `setBrakeMode(mode)` | `motors.setBrakeMode(BrakeMode::BRAKE)` |
| ç²å–è§’åº¦ | `getAngle()` | `Angle a = motors.getAngle()` |
| è¨­ç½®è§’åº¦ | `setAngle(angle)` | `motors.setAngle(0_stDeg)` |
| ç²å–æº«åº¦ | `getTemperature()` | `Temperature t = motors.getTemperature()` |

### IMU æ§åˆ¶

| åŠŸèƒ½ | æŒ‡ä»¤ | ç¯„ä¾‹ |
|------|------|------|
| æ ¡æº– | `calibrate()` | `imu.calibrate()` |
| æª¢æŸ¥æ ¡æº– | `isCalibrated()` | `if (imu.isCalibrated())` |
| ç²å–æ—‹è½‰ | `getRotation()` | `Angle r = imu.getRotation()` |
| ç²å–èˆªå‘ | `getHeading()` | `Angle h = imu.getHeading()` |
| è¨­ç½®æ—‹è½‰ | `setRotation(angle)` | `imu.setRotation(0_stDeg)` |

### é‹å‹•æ§åˆ¶

| åŠŸèƒ½ | æŒ‡ä»¤ | ç¯„ä¾‹ |
|------|------|------|
| ç§»å‹•åˆ°é» | `moveToPoint()` | `moveToPoint({24_in, 24_in}, 5_sec)` |
| ç§»å‹•åˆ°å§¿æ…‹ | `moveToPose()` | `moveToPose({24_in, 24_in, 90_cDeg}, 5_sec)` |
| è½‰å‘ | `turnTo()` | `turnTo(90_cDeg, 3_sec)` |
| è·¯å¾‘è·Ÿéš¨ | `follow()` | `follow(path, 8_in, 20_sec)` |

### é‡Œç¨‹è¨ˆ

| åŠŸèƒ½ | æŒ‡ä»¤ | ç¯„ä¾‹ |
|------|------|------|
| å•Ÿå‹•è¿½è¹¤ | `startTask()` | `odom.startTask()` |
| è¨­ç½®ä½ç½® | `setPose()` | `odom.setPose({0_in, 0_in, 0_cDeg})` |
| ç²å–ä½ç½® | `getPose()` | `Pose p = odom.getPose()` |

### å–®ä½è½‰æ›

| é¡å‹ | è½‰æ›å‡½æ•¸ | ç¯„ä¾‹ |
|------|----------|------|
| é•·åº¦ | `to_in()`, `to_cm()`, `to_m()` | `to_in(24_cm)` |
| è§’åº¦ | `to_cDeg()`, `to_stDeg()`, `to_stRad()` | `to_stDeg(90_cDeg)` |
| æº«åº¦ | `to_celsius()`, `to_fahrenheit()` | `to_celsius(temp)` |
| é›»æµ | `to_amp()`, `to_mamp()` | `to_amp(current)` |

---

## ğŸ“ åƒè€ƒè³‡æº

- **LemLib æ–‡æª”**: [https://lemlib.github.io/LemLib/](https://lemlib.github.io/LemLib/)
- **PROS æ–‡æª”**: [https://pros.cs.purdue.edu/](https://pros.cs.purdue.edu/)
- **GitHub**: [https://github.com/LemLib/LemLib](https://github.com/LemLib/LemLib)

---

**æ–‡æª”ç‰ˆæœ¬**: 2.0.0  
**æœ€å¾Œæ›´æ–°**: 2025å¹´11æœˆ8æ—¥

### ğŸ¯ å°ˆæ¡ˆç›®æ¨™
LemLib_1009 æ˜¯ä¸€å€‹åŸºæ–¼ LemLib æ¡†æ¶çš„ VEX V5 æ©Ÿå™¨äººè‡ªä¸»æ§åˆ¶ç³»çµ±ï¼Œæä¾›é«˜ç²¾åº¦çš„é‹å‹•æ§åˆ¶ã€è·¯å¾‘è·Ÿéš¨å’Œé‡Œç¨‹è¨ˆå®šä½åŠŸèƒ½ã€‚

### âœ¨ ä¸»è¦ç‰¹è‰²
- âœ… é«˜ç²¾åº¦é‡Œç¨‹è¨ˆå®šä½ç³»çµ±
- âœ… å¤šç¨®é‹å‹•æ§åˆ¶ç®—æ³• (moveToPoint, moveToPose, turnTo, follow)
- âœ… PID é–‰ç’°æ§åˆ¶
- âœ… è·¯å¾‘è¦åŠƒèˆ‡è·Ÿéš¨
- âœ… æ…£æ€§æ¸¬é‡å–®å…ƒ (IMU) æ•´åˆ
- âœ… è¿½è¹¤è¼ªé‡Œç¨‹è¨ˆ
- âœ… å¯¦æ™‚ä½ç½®ç›£æ§èˆ‡æ—¥èªŒè¨˜éŒ„

### ğŸ› ï¸ æŠ€è¡“æ£§
- **èªè¨€**: C++23
- **æ¡†æ¶**: LemLib v0.6.0
- **å¹³å°**: PROS 4.x
- **ç¡¬é«”**: VEX V5
- **å·¥å…·éˆ**: ARM GCC

---

## ç³»çµ±æ¶æ§‹

```
LemLib_1009/
â”œâ”€â”€ src/                    # æºä»£ç¢¼
â”‚   â”œâ”€â”€ main.cpp           # ä¸»ç¨‹åºå…¥å£
â”‚   â”œâ”€â”€ config.cpp         # ç¡¬é«”é…ç½®
â”‚   â””â”€â”€ lemlib/            # LemLib æ ¸å¿ƒå¯¦ç¾
â”‚       â”œâ”€â”€ motions/       # é‹å‹•æ§åˆ¶ç®—æ³•
â”‚       â”œâ”€â”€ tracking/      # é‡Œç¨‹è¨ˆè¿½è¹¤
â”‚       â”œâ”€â”€ PID.cpp        # PID æ§åˆ¶å™¨
â”‚       â””â”€â”€ util.cpp       # å·¥å…·å‡½æ•¸
â”œâ”€â”€ include/               # é ­æ–‡ä»¶
â”‚   â”œâ”€â”€ lemlib/           # LemLib API
â”‚   â”œâ”€â”€ hardware/         # ç¡¬é«”æŠ½è±¡å±¤
â”‚   â”œâ”€â”€ units/            # å–®ä½ç³»çµ±
â”‚   â””â”€â”€ pros/             # PROS API
â”œâ”€â”€ static/               # éœæ…‹è³‡æº
â”‚   â””â”€â”€ example.txt       # è·¯å¾‘æ•¸æ“šæ–‡ä»¶
â””â”€â”€ firmware/             # V5 å›ºä»¶åº«
```

---

## ç¡¬é«”é…ç½®

### ğŸ¤– é©…å‹•ç³»çµ±

#### å·¦å´é¦¬é”ç¾¤çµ„
```cpp
lemlib::MotorGroup left_motors({-1, 11, -12, 13}, 360_rpm);
```
- **åŸ è™Ÿ**: 1 (åè½‰), 11, 12 (åè½‰), 13
- **é€Ÿåº¦**: 360 RPM (æœ€é«˜é€Ÿåº¦æª”)
- **æ•¸é‡**: 4 å€‹é¦¬é”
- **ç”¨é€”**: å·¦å´é©…å‹•

#### å³å´é¦¬é”ç¾¤çµ„
```cpp
lemlib::MotorGroup right_motors({8, 10}, 360_rpm);
```
- **åŸ è™Ÿ**: 8, 10
- **é€Ÿåº¦**: 360 RPM (æœ€é«˜é€Ÿåº¦æª”)
- **æ•¸é‡**: 2 å€‹é¦¬é”
- **ç”¨é€”**: å³å´é©…å‹•

### ğŸ“¡ æ„Ÿæ¸¬å™¨é…ç½®

#### æ…£æ€§æ¸¬é‡å–®å…ƒ (IMU)
```cpp
lemlib::V5InertialSensor imu(1);
```
- **åŸ è™Ÿ**: 1
- **é¡å‹**: V5 Inertial Sensor
- **åŠŸèƒ½**: æä¾›è§’åº¦ã€è§’é€Ÿåº¦ã€åŠ é€Ÿåº¦æ•¸æ“š
- **ç”¨é€”**: æ©Ÿå™¨äººæ–¹å‘è¿½è¹¤ã€ç©©å®šæ€§æ§åˆ¶

#### å‚ç›´è¿½è¹¤è¼ª
```cpp
lemlib::TrackingWheel vertical_tracker('E', 'F', true, 2.75_in, 26.5_cm / 2);
```
- **åŸ è™Ÿ**: ADI E, F (ç·¨ç¢¼å™¨)
- **åè½‰**: æ˜¯
- **è¼ªå¾‘**: 2.75 è‹±å¯¸
- **åç§»**: 13.25 cm (å³å´)
- **ç”¨é€”**: Y è»¸ä½ç§»è¿½è¹¤

#### æ°´å¹³è¿½è¹¤è¼ª
```cpp
lemlib::TrackingWheel horizontal_tracker('G', 'H', false, 2.75_in, -26.5_cm / 2);
```
- **åŸ è™Ÿ**: ADI G, H (ç·¨ç¢¼å™¨)
- **åè½‰**: å¦
- **è¼ªå¾‘**: 2.75 è‹±å¯¸
- **åç§»**: -13.25 cm (å¾Œå´)
- **ç”¨é€”**: X è»¸ä½ç§»è¿½è¹¤

### ğŸ“ åº•ç›¤åƒæ•¸
```cpp
const Length track_width = 26.5_cm;  // åº•ç›¤å¯¬åº¦
```

---

## æ ¸å¿ƒåŠŸèƒ½æ¨¡çµ„

### 1ï¸âƒ£ é‡Œç¨‹è¨ˆç³»çµ± (Odometry)

#### åŠŸèƒ½æè¿°
è¿½è¹¤æ©Ÿå™¨äººåœ¨å ´åœ°ä¸Šçš„çµ•å°ä½ç½® (x, y, Î¸)ã€‚

#### å¯¦ç¾æ–¹å¼
```cpp
lemlib::TrackingWheelOdometry odom({&imu}, {&vertical_tracker}, {&horizontal_tracker});
```

#### ä¸»è¦åŠŸèƒ½
- **ä½ç½®è¿½è¹¤**: å¯¦æ™‚è¨ˆç®—æ©Ÿå™¨äººä½ç½®
- **æ–¹å‘è¿½è¹¤**: çµåˆ IMU å’Œç·¨ç¢¼å™¨æ•¸æ“š
- **æ•¸æ“šèåˆ**: å¤šæ„Ÿæ¸¬å™¨æ•¸æ“šæ•´åˆ
- **ä½ç½®é‡ç½®**: `setPose()` è¨­ç½®åˆå§‹ä½ç½®

#### ä½¿ç”¨ç¯„ä¾‹
```cpp
// è¨­ç½®èµ·å§‹ä½ç½®
odom.setPose({0_in, 0_in, 0_cDeg});

// ç²å–ç•¶å‰ä½ç½®
auto pose = odom.getPose();
auto x = to_in(pose.x);        // X åº§æ¨™ (è‹±å¯¸)
auto y = to_in(pose.y);        // Y åº§æ¨™ (è‹±å¯¸)
auto theta = to_cDeg(pose.orientation);  // æ–¹å‘ (åº¦)
```

---

### 2ï¸âƒ£ PID æ§åˆ¶å™¨

#### åŠŸèƒ½æè¿°
æ¯”ä¾‹-ç©åˆ†-å¾®åˆ†æ§åˆ¶å™¨ï¼Œç”¨æ–¼ç²¾ç¢ºæ§åˆ¶æ©Ÿå™¨äººé‹å‹•ã€‚

#### é…ç½®åƒæ•¸
```cpp
// è§’å‘ PID (è½‰å‘)
const lemlib::PID angular_pid(0.05, 0, 0);

// æ©«å‘ PID (å‰é€²/å¾Œé€€)
const lemlib::PID lateral_pid(0, 0, 0);
```

#### åƒæ•¸èªªæ˜
| åƒæ•¸ | ç¬¦è™Ÿ | è§’å‘å€¼ | æ©«å‘å€¼ | åŠŸèƒ½ |
|------|------|--------|--------|------|
| æ¯”ä¾‹å¢ç›Š | kP | 0.05 | 0 | èª¤å·®éŸ¿æ‡‰é€Ÿåº¦ |
| ç©åˆ†å¢ç›Š | kI | 0 | 0 | ç´¯ç©èª¤å·®æ¶ˆé™¤ |
| å¾®åˆ†å¢ç›Š | kD | 0 | 0 | éœ‡ç›ªæŠ‘åˆ¶ |

#### PID æ§åˆ¶æµç¨‹
```
èª¤å·®è¨ˆç®— â†’ PID é‹ç®— â†’ è¼¸å‡ºé™åˆ¶ â†’ æ–œç‡é™åˆ¶ â†’ é¦¬é”è¼¸å‡º
   â†‘                                              â†“
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ åé¥‹å¾ªç’° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 3ï¸âƒ£ é‹å‹•æ§åˆ¶ç®—æ³•

#### A. moveToPoint - ç§»å‹•åˆ°é»
**åŠŸèƒ½**: å°‡æ©Ÿå™¨äººç§»å‹•åˆ°æŒ‡å®šçš„ (x, y) åº§æ¨™

**åƒæ•¸çµæ§‹**:
```cpp
struct MoveToPointParams {
    bool reversed = false;              // æ˜¯å¦å€’è»Š
    Number maxLateralSpeed = 1;         // æœ€å¤§æ©«å‘é€Ÿåº¦ (0-1)
    Number minLateralSpeed = 0;         // æœ€å°æ©«å‘é€Ÿåº¦
    Number maxAngularSpeed = 1;         // æœ€å¤§è§’å‘é€Ÿåº¦ (0-1)
    Number lateralSlew = lateral_slew;  // æ©«å‘åŠ é€Ÿåº¦é™åˆ¶
    Number angularSlew = angular_slew;  // è§’å‘åŠ é€Ÿåº¦é™åˆ¶
    Length earlyExitRange = 0_in;       // æå‰é€€å‡ºç¯„åœ
};
```

**æ§åˆ¶é‚è¼¯**:
1. è¨ˆç®—åˆ°ç›®æ¨™é»çš„è·é›¢å’Œè§’åº¦èª¤å·®
2. ç•¶è·é›¢ < 7.5 è‹±å¯¸æ™‚é€²å…¥ settling æ¨¡å¼
3. settling æ¨¡å¼ä¸‹åœæ­¢è½‰å‘ï¼Œåªé€²è¡Œç›´ç·šèª¿æ•´
4. ä½¿ç”¨ exit conditions åˆ¤æ–·æ˜¯å¦åˆ°é”ç›®æ¨™

**é€Ÿåº¦æ§åˆ¶**:
```cpp
// é€²å…¥ settling æ¨¡å¼æ™‚çš„é€Ÿåº¦èª¿æ•´
if (pose.distanceTo(target) < 7.5_in) {
    close = true;
    params.maxLateralSpeed = max(abs(prevLateralOut), 0.47);  // æœ€å° 47%
    params.maxAngularSpeed = max(abs(prevAngularOut), 0.47);
}
```

---

#### B. moveToPose - ç§»å‹•åˆ°å§¿æ…‹
**åŠŸèƒ½**: å°‡æ©Ÿå™¨äººç§»å‹•åˆ°æŒ‡å®šçš„ä½ç½®å’Œæ–¹å‘ (x, y, Î¸)

**åƒæ•¸çµæ§‹**:
```cpp
struct MoveToPoseParams {
    bool reversed = false;              // æ˜¯å¦å€’è»Š
    Number maxLateralSpeed = 1;         // æœ€å¤§æ©«å‘é€Ÿåº¦
    Number minLateralSpeed = 0;         // æœ€å°æ©«å‘é€Ÿåº¦
    Number maxAngularSpeed = 1;         // æœ€å¤§è§’å‘é€Ÿåº¦
    Number lateralSlew = lateral_slew;  // æ©«å‘åŠ é€Ÿåº¦é™åˆ¶
    Number angularSlew = angular_slew;  // è§’å‘åŠ é€Ÿåº¦é™åˆ¶
    Number lead = 0.6;                  // å…ˆå°ä¿‚æ•¸ (carrot point)
    Length earlyExitRange = 0_in;       // æå‰é€€å‡ºç¯„åœ
    Number driftCompensation = 0;       // æ¼‚ç§»è£œå„Ÿä¿‚æ•¸
};
```

**æ§åˆ¶é‚è¼¯**:
1. ä½¿ç”¨ carrot point ç®—æ³•é€²è¡Œè·¯å¾‘è¦åŠƒ
2. åŒæ™‚æ§åˆ¶ä½ç½®å’Œæ–¹å‘
3. åœ¨æ¥è¿‘ç›®æ¨™æ™‚åˆ‡æ›åˆ°æœ€çµ‚å§¿æ…‹å°é½Š
4. é˜²æ­¢å´æ»‘çš„é€Ÿåº¦é™åˆ¶

**Carrot Point ç®—æ³•**:
```cpp
// è¨ˆç®— carrot point (å¼•å°é»)
const V2Position carrot = target - V2Position::fromPolar(
    target.orientation, 
    params.lead * pose.distanceTo(target)
);
```

---

#### C. turnTo - è½‰å‘ç›®æ¨™
**åŠŸèƒ½**: å°‡æ©Ÿå™¨äººè½‰å‘æŒ‡å®šè§’åº¦æˆ–é¢å‘æŒ‡å®šé»

**åƒæ•¸çµæ§‹**:
```cpp
struct TurnToParams {
    Number maxSpeed = 1;                           // æœ€å¤§è½‰é€Ÿ
    Number minSpeed = 0;                           // æœ€å°è½‰é€Ÿ
    Number slew = angular_slew;                    // åŠ é€Ÿåº¦é™åˆ¶
    std::optional<AngularDirection> direction;     // è½‰å‘æ–¹å‘
    std::optional<LockedSide> lockedSide;         // é–å®šå´
    Length earlyExitRange = 0_in;                  // æå‰é€€å‡º
};
```

**è½‰å‘æ¨¡å¼**:
- **è½‰åˆ°è§’åº¦**: `turnTo(90_cDeg, timeout)`
- **é¢å‘é»**: `turnTo({24_in, 24_in}, timeout)`

**é–å®šå´åŠŸèƒ½**:
```cpp
// é–å®šå·¦å´ï¼Œåªç”¨å³å´è½‰å‘ (pivot turn)
params.lockedSide = TurnToParams::LockedSide::LEFT;
```

---

#### D. follow - è·¯å¾‘è·Ÿéš¨
**åŠŸèƒ½**: æ²¿è‘—é å®šç¾©çš„è·¯å¾‘ç§»å‹•

**åƒæ•¸çµæ§‹**:
```cpp
struct FollowParams {
    bool reversed = false;              // æ˜¯å¦å€’è»Šè·Ÿéš¨
    Number lateralSlew = lateral_slew;  // åŠ é€Ÿåº¦é™åˆ¶
};
```

**è·¯å¾‘æ ¼å¼**:
```
x1, y1, speed1
x2, y2, speed2
x3, y3, speed3
...
endData
```

**ä½¿ç”¨ç¯„ä¾‹**:
```cpp
// ç›´æ¥ä½¿ç”¨æ–‡ä»¶è³‡æº
ASSET(example_txt);
lemlib::follow(example_txt, 8_in, 25_sec, {}, {});

// åƒæ•¸èªªæ˜
// 8_in: lookahead distance (å‰ç»è·é›¢)
// 25_sec: timeout (è¶…æ™‚æ™‚é–“)
// {}: ä½¿ç”¨é è¨­ FollowParams
// {}: ä½¿ç”¨é è¨­ FollowSettings
```

**Pure Pursuit ç®—æ³•**:
1. å¾ç•¶å‰ä½ç½®è¨ˆç®—å‰ç»é»
2. è¨ˆç®—åˆ°é”å‰ç»é»æ‰€éœ€çš„æ›²ç‡
3. è½‰æ›ç‚ºå·¦å³è¼ªé€Ÿåº¦
4. å‹•æ…‹èª¿æ•´é€Ÿåº¦ä»¥é©æ‡‰è·¯å¾‘æ›²ç‡

---

### 4ï¸âƒ£ é€€å‡ºæ¢ä»¶ç³»çµ±

#### åŠŸèƒ½æè¿°
åˆ¤æ–·é‹å‹•æ˜¯å¦å®Œæˆçš„æ¢ä»¶æª¢æŸ¥ç³»çµ±ã€‚

#### é…ç½®
```cpp
// è§’åº¦é€€å‡ºæ¢ä»¶: èª¤å·® < 1åº¦ ä¸”æŒçºŒ 2ç§’
const lemlib::ExitConditionGroup<AngleRange> angular_exit_conditions(
    {lemlib::ExitCondition<AngleRange>(1_stDeg, 2_sec)}
);

// ä½ç§»é€€å‡ºæ¢ä»¶: èª¤å·® < 1è‹±å¯¸ ä¸”æŒçºŒ 500æ¯«ç§’
const lemlib::ExitConditionGroup<Length> lateral_exit_conditions(
    {lemlib::ExitCondition<Length>(1_in, 500_msec)}
);
```

#### å·¥ä½œåŸç†
```cpp
// æ¯å€‹å¾ªç’°æ›´æ–°é€€å‡ºæ¢ä»¶
if (settings.exitConditions.update(lateralError) && close) {
    break;  // æ¢ä»¶æ»¿è¶³ï¼Œé€€å‡ºé‹å‹•
}
```

---

### 5ï¸âƒ£ å–®ä½ç³»çµ±

#### æ”¯æ´çš„å–®ä½é¡å‹
- **é•·åº¦**: `_in` (è‹±å¯¸), `_cm` (å˜ç±³), `_m` (ç±³)
- **è§’åº¦**: `_deg` (åº¦), `_cDeg` (å˜åº¦), `_stDeg` (æ¨™æº–åº¦), `_rad` (å¼§åº¦)
- **é€Ÿåº¦**: `_rpm` (è½‰/åˆ†)
- **æ™‚é–“**: `_sec` (ç§’), `_msec` (æ¯«ç§’)
- **ç™¾åˆ†æ¯”**: `_pct` (ç™¾åˆ†æ¯”)

#### å–®ä½è½‰æ›
```cpp
// é•·åº¦è½‰æ›
Length distance = 24_in;
Number meters = to_m(distance);      // è½‰ç‚ºç±³
Number inches = to_in(distance);     // è½‰ç‚ºè‹±å¯¸

// è§’åº¦è½‰æ›
Angle heading = 90_cDeg;
Number degrees = to_cDeg(heading);   // è½‰ç‚ºå˜åº¦
Number radians = to_stRad(heading);  // è½‰ç‚ºå¼§åº¦
```

---

## ä½¿ç”¨ç¯„ä¾‹

### ğŸš€ åˆå§‹åŒ–åºåˆ—

```cpp
void initialize() {
    // 1. è¨­ç½®æ—¥èªŒç´šåˆ¥
    terminal.setLoggingLevel(logger::Level::DEBUG);
    
    // 2. åˆå§‹åŒ– LCD é¡¯ç¤º
    pros::lcd::initialize();
    
    // 3. æ ¡æº– IMU (éœ€è¦ 3.2 ç§’)
    imu.calibrate();
    pros::delay(3200);
    
    // 4. å•Ÿå‹•é‡Œç¨‹è¨ˆè¿½è¹¤ä»»å‹™
    odom.startTask();
    pros::delay(100);
    
    // 5. å‰µå»ºä½ç½®é¡¯ç¤ºä»»å‹™
    pros::Task([] {
        while (true) {
            auto p = odom.getPose();
            pros::lcd::print(0, "X: %f", to_in(p.x));
            pros::lcd::print(1, "Y: %f", to_in(p.y));
            pros::lcd::print(2, "Theta: %f", to_cDeg(p.orientation));
            pros::delay(10);
        }
    });
    
    // 6. æ¸¬è©¦è½‰å‘åŠŸèƒ½
    lemlib::turnTo(90_cDeg, 100_sec);
}
```

---

### ğŸ¯ è‡ªä¸»ç¨‹åºç¯„ä¾‹

```cpp
void autonomous() {
    // === ç¯„ä¾‹ 1: åŸºæœ¬è·¯å¾‘è·Ÿéš¨ ===
    odom.setPose({0_in, 0_in, 0_cDeg});
    pros::delay(100);
    
    pros::lcd::print(3, "Following example.txt");
    lemlib::follow(example_txt, 8_in, 25_sec, {}, {});
    
    // === ç¯„ä¾‹ 2: ä¸åŒå‰ç»è·é›¢ ===
    pros::delay(2000);
    odom.setPose({0_in, 0_in, 0_cDeg});
    
    pros::lcd::print(5, "Different lookahead...");
    lemlib::follow(example_txt, 6_in, 20_sec, {}, {});
    
    // === ç¯„ä¾‹ 3: å€’è»Šè·Ÿéš¨ ===
    pros::delay(2000);
    odom.setPose({27.369_in, 46.871_in, 0_cDeg});
    pros::lcd::print(6, "Reverse example.txt...");
    
    lemlib::FollowParams reverseParams;
    reverseParams.reversed = true;
    lemlib::follow(example_txt, 10_in, 25_sec, reverseParams, {});
    
    // === ç¯„ä¾‹ 4: ç²¾ç¢ºè·Ÿéš¨ ===
    pros::delay(2000);
    odom.setPose({0_in, 0_in, 0_cDeg});
    pros::lcd::print(7, "Precise follow...");
    
    lemlib::follow(example_txt, 4_in, 30_sec, {}, {});
    
    pros::lcd::print(0, "Example.txt complete!");
}
```

---

## API åƒè€ƒ

### ğŸ“ ä½ç½®èˆ‡å§¿æ…‹

#### Pose (å§¿æ…‹)
```cpp
struct Pose {
    Length x;              // X åº§æ¨™
    Length y;              // Y åº§æ¨™
    Angle orientation;     // æ–¹å‘è§’
};

// å‰µå»ºå§¿æ…‹
units::Pose pose = {24_in, 12_in, 90_cDeg};
```

#### V2Position (2D ä½ç½®)
```cpp
struct V2Position {
    Length x;              // X åº§æ¨™
    Length y;              // Y åº§æ¨™
};

// å‰µå»ºä½ç½®
units::V2Position pos = {24_in, 12_in};
```

---

### ğŸ® é‹å‹•æ§åˆ¶ API

#### moveToPoint
```cpp
void moveToPoint(
    units::V2Position target,      // ç›®æ¨™ä½ç½®
    Time timeout,                  // è¶…æ™‚æ™‚é–“
    MoveToPointParams params,      // é‹å‹•åƒæ•¸
    MoveToPointSettings settings   // è¨­ç½®
);

// ç¯„ä¾‹
lemlib::moveToPoint({24_in, 24_in}, 5_sec, {}, {});
```

#### moveToPose
```cpp
void moveToPose(
    units::Pose target,            // ç›®æ¨™å§¿æ…‹
    Time timeout,                  // è¶…æ™‚æ™‚é–“
    MoveToPoseParams params,       // é‹å‹•åƒæ•¸
    MoveToPoseSettings settings    // è¨­ç½®
);

// ç¯„ä¾‹
lemlib::moveToPose({24_in, 24_in, 90_cDeg}, 5_sec, {}, {});
```

#### turnTo
```cpp
void turnTo(
    std::variant<Angle, V2Position> target,  // è§’åº¦æˆ–ä½ç½®
    Time timeout,                             // è¶…æ™‚æ™‚é–“
    TurnToParams params,                      // é‹å‹•åƒæ•¸
    TurnToSettings settings                   // è¨­ç½®
);

// ç¯„ä¾‹ 1: è½‰åˆ°è§’åº¦
lemlib::turnTo(90_cDeg, 3_sec, {}, {});

// ç¯„ä¾‹ 2: é¢å‘é»
lemlib::turnTo({24_in, 24_in}, 3_sec, {}, {});
```

#### follow
```cpp
void follow(
    const asset& path,             // è·¯å¾‘è³‡æº
    Length lookaheadDistance,      // å‰ç»è·é›¢
    Time timeout,                  // è¶…æ™‚æ™‚é–“
    FollowParams params,           // é‹å‹•åƒæ•¸
    FollowSettings settings        // è¨­ç½®
);

// ç¯„ä¾‹
ASSET(my_path);
lemlib::follow(my_path, 8_in, 20_sec, {}, {});
```

---

### ğŸ“Š é‡Œç¨‹è¨ˆ API

```cpp
// è¨­ç½®ä½ç½®
odom.setPose({0_in, 0_in, 0_cDeg});

// ç²å–ä½ç½®
units::Pose pose = odom.getPose();

// å•Ÿå‹•è¿½è¹¤ä»»å‹™
odom.startTask();

// åœæ­¢è¿½è¹¤ä»»å‹™
odom.stopTask();
```

---

### âš™ï¸ PID API

```cpp
// å‰µå»º PID æ§åˆ¶å™¨
lemlib::PID pid(kP, kI, kD);

// æ›´æ–° PID (è¿”å›è¼¸å‡º)
Number output = pid.update(error);

// é‡ç½® PID
pid.reset();

// è¨­ç½®å¢ç›Š
lemlib::Gains newGains = {1.0, 0.1, 0.01};
pid.setGains(newGains);

// ç²å–å¢ç›Š
lemlib::Gains currentGains = pid.getGains();
```

---

## åƒæ•¸èª¿æ ¡æŒ‡å—

### ğŸšï¸ PID èª¿åƒæ­¥é©Ÿ

#### 1. èª¿æ•´ kP (æ¯”ä¾‹å¢ç›Š)
```
ç›®æ¨™: å¿«é€ŸéŸ¿æ‡‰ï¼Œå…è¨±ä¸€å®šè¶…èª¿
æ–¹æ³•: å¾å°åˆ°å¤§é€æ­¥å¢åŠ 
è§€å¯Ÿ: éŸ¿æ‡‰é€Ÿåº¦ã€è¶…èª¿é‡
å»ºè­°å€¼: 0.03 - 0.1
```

#### 2. èª¿æ•´ kD (å¾®åˆ†å¢ç›Š)
```
ç›®æ¨™: æ¸›å°‘éœ‡ç›ªå’Œè¶…èª¿
æ–¹æ³•: åœ¨æœ‰ kP çš„åŸºç¤ä¸Šæ·»åŠ 
è§€å¯Ÿ: éœ‡ç›ªæŠ‘åˆ¶æ•ˆæœ
å»ºè­°å€¼: kP çš„ 1/10 åˆ° 1/5
```

#### 3. èª¿æ•´ kI (ç©åˆ†å¢ç›Š)
```
ç›®æ¨™: æ¶ˆé™¤ç©©æ…‹èª¤å·®
æ–¹æ³•: æœ€å¾Œæ·»åŠ ï¼Œè¬¹æ…èª¿æ•´
è§€å¯Ÿ: æ˜¯å¦æœ‰ç©©æ…‹èª¤å·®
å»ºè­°å€¼: å¾ˆå°çš„å€¼ï¼Œé€šå¸¸ < 0.01
```

---

### ğŸš— é€Ÿåº¦åƒæ•¸èª¿æ ¡

#### maxLateralSpeed (æœ€å¤§æ©«å‘é€Ÿåº¦)
```cpp
å»ºè­°ç¯„åœ: 0.6 - 1.0
ç”¨é€”: æ§åˆ¶å‰é€²/å¾Œé€€çš„æœ€å¤§é€Ÿåº¦
å½±éŸ¿: éé«˜å¯èƒ½å¤±æ§ï¼Œéä½å¤ªæ…¢
èª¿æ ¡: å¾ 0.8 é–‹å§‹ï¼Œæ ¹æ“šå ´åœ°èª¿æ•´
```

#### minLateralSpeed (æœ€å°æ©«å‘é€Ÿåº¦)
```cpp
å»ºè­°ç¯„åœ: 0.2 - 0.4
ç”¨é€”: é˜²æ­¢é¦¬é”åœæ»¯
å½±éŸ¿: éä½å¯èƒ½ç„¡æ³•å…‹æœæ‘©æ“¦åŠ›
èª¿æ ¡: æ‰¾åˆ°æ©Ÿå™¨äººèƒ½ç©©å®šç§»å‹•çš„æœ€å°å€¼
```

#### maxAngularSpeed (æœ€å¤§è§’å‘é€Ÿåº¦)
```cpp
å»ºè­°ç¯„åœ: 0.5 - 0.8
ç”¨é€”: æ§åˆ¶è½‰å‘çš„æœ€å¤§é€Ÿåº¦
å½±éŸ¿: éé«˜è½‰å‘å¤ªå¿«ï¼Œéä½è½‰å‘å¤ªæ…¢
èª¿æ ¡: é€šå¸¸æ¯” maxLateralSpeed ç•¥ä½
```

---

### ğŸ“ è·¯å¾‘è·Ÿéš¨åƒæ•¸

#### lookaheadDistance (å‰ç»è·é›¢)
```cpp
å»ºè­°ç¯„åœ: 4_in - 12_in
ç”¨é€”: Pure Pursuit ç®—æ³•çš„å‰è¦–è·é›¢
å½±éŸ¿: 
  - å¤ªå°: è·¯å¾‘è·Ÿéš¨ä¸å¹³æ»‘ï¼Œæ˜“éœ‡ç›ª
  - å¤ªå¤§: åˆ‡å½éå¤§ï¼Œä¸ç²¾ç¢º
èª¿æ ¡å»ºè­°:
  - é«˜é€Ÿè·¯å¾‘: 8-12 è‹±å¯¸
  - ä½é€Ÿè·¯å¾‘: 4-6 è‹±å¯¸
  - è¤‡é›œè·¯å¾‘: 6-8 è‹±å¯¸
```

#### lead (å…ˆå°ä¿‚æ•¸)
```cpp
å»ºè­°ç¯„åœ: 0.4 - 0.8
ç”¨é€”: moveToPose ä¸­ carrot point çš„è·é›¢ä¿‚æ•¸
å½±éŸ¿: æ§åˆ¶æ¥è¿‘ç›®æ¨™æ™‚çš„è¡Œç‚º
èª¿æ ¡: 0.6 æ˜¯ç¶“é©—æœ€ä½³å€¼
```

---

### âš¡ åŠ é€Ÿåº¦é™åˆ¶ (Slew)

#### lateralSlew (æ©«å‘æ–œç‡)
```cpp
å»ºè­°ç¯„åœ: 0.5 - 3.0
å–®ä½: åŠŸç‡è®ŠåŒ–/ç§’
ç”¨é€”: é™åˆ¶å‰é€²/å¾Œé€€çš„åŠ é€Ÿåº¦
èª¿æ ¡:
  - é«˜å€¼: å¿«é€ŸåŠ é€Ÿï¼Œå¯èƒ½æ‰“æ»‘
  - ä½å€¼: å¹³æ»‘åŠ é€Ÿï¼Œè¼ƒæ…¢
  - å»ºè­°: å¾ 1.0 é–‹å§‹
```

#### angularSlew (è§’å‘æ–œç‡)
```cpp
å»ºè­°ç¯„åœ: 0.5 - 2.0
å–®ä½: åŠŸç‡è®ŠåŒ–/ç§’
ç”¨é€”: é™åˆ¶è½‰å‘çš„åŠ é€Ÿåº¦
èª¿æ ¡:
  - å»ºè­°: é€šå¸¸èˆ‡ lateralSlew ç›¸åŒ
  - å¯ä»¥ç•¥é«˜ä»¥å…è¨±å¿«é€Ÿè½‰å‘
```

---

### ğŸ¯ é€€å‡ºæ¢ä»¶èª¿æ ¡

#### è·é›¢é–¾å€¼
```cpp
å»ºè­°ç¯„åœ: 0.5_in - 2_in
ç”¨é€”: åˆ¤æ–·æ˜¯å¦åˆ°é”ç›®æ¨™çš„è·é›¢å®¹å·®
èª¿æ ¡:
  - ç²¾ç¢ºä»»å‹™: 0.5 - 1 è‹±å¯¸
  - ä¸€èˆ¬ä»»å‹™: 1 - 2 è‹±å¯¸
```

#### æ™‚é–“é–¾å€¼
```cpp
å»ºè­°ç¯„åœ: 200_msec - 1_sec
ç”¨é€”: ç©©å®šæ™‚é–“è¦æ±‚
èª¿æ ¡:
  - å¿«é€Ÿç§»å‹•: 200-500 æ¯«ç§’
  - ç²¾ç¢ºåœæ­¢: 500-1000 æ¯«ç§’
```

---

### ğŸ”§ å¸¸è¦‹å•é¡Œæ’æŸ¥

#### å•é¡Œ 1: æ©Ÿå™¨äººéœ‡ç›ªä¸ç©©å®š
```
å¯èƒ½åŸå› :
  - kP éå¤§
  - kD ä¸è¶³
  - slew å¤ªé«˜
è§£æ±ºæ–¹æ¡ˆ:
  1. é™ä½ kP
  2. å¢åŠ  kD
  3. é™ä½ lateralSlew å’Œ angularSlew
```

#### å•é¡Œ 2: éŸ¿æ‡‰å¤ªæ…¢
```
å¯èƒ½åŸå› :
  - kP éå°
  - slew å¤ªä½
  - maxSpeed å¤ªä½
è§£æ±ºæ–¹æ¡ˆ:
  1. å¢åŠ  kP
  2. å¢åŠ  slew
  3. æé«˜ maxSpeed
```

#### å•é¡Œ 3: ç„¡æ³•åˆ°é”ç›®æ¨™
```
å¯èƒ½åŸå› :
  - minSpeed å¤ªä½
  - é€€å‡ºæ¢ä»¶å¤ªåš´æ ¼
  - è¶…æ™‚æ™‚é–“å¤ªçŸ­
è§£æ±ºæ–¹æ¡ˆ:
  1. æé«˜ minSpeed (è‡³å°‘ 0.3)
  2. æ”¾å¯¬é€€å‡ºæ¢ä»¶é–¾å€¼
  3. å¢åŠ  timeout
```

#### å•é¡Œ 4: è·¯å¾‘è·Ÿéš¨åé›¢
```
å¯èƒ½åŸå› :
  - lookaheadDistance ä¸ç•¶
  - é€Ÿåº¦éå¿«
  - é‡Œç¨‹è¨ˆèª¤å·®ç´¯ç©
è§£æ±ºæ–¹æ¡ˆ:
  1. èª¿æ•´ lookaheadDistance
  2. é™ä½é€Ÿåº¦
  3. æ ¡æº–è¿½è¹¤è¼ªå’Œ IMU
```

---

## ğŸ’¡ æœ€ä½³å¯¦è¸

### 1. åˆå§‹åŒ–é †åº
```cpp
âœ… æ­£ç¢ºé †åº:
1. æ—¥èªŒç³»çµ±
2. LCD é¡¯ç¤º
3. IMU æ ¡æº– (ç­‰å¾…å®Œæˆ)
4. é‡Œç¨‹è¨ˆå•Ÿå‹•
5. å…¶ä»–å‚³æ„Ÿå™¨

âŒ éŒ¯èª¤: ä¸ç­‰å¾… IMU æ ¡æº–å®Œæˆå°±å•Ÿå‹•é‡Œç¨‹è¨ˆ
```

### 2. ä½ç½®è¨­ç½®
```cpp
âœ… åœ¨æ¯å€‹è‡ªä¸»ç¨‹åºé–‹å§‹æ™‚è¨­ç½®
odom.setPose({0_in, 0_in, 0_cDeg});

âœ… åœ¨é‡ç½®ä½ç½®å¾Œç­‰å¾…ä¸€å°æ®µæ™‚é–“
pros::delay(100);
```

### 3. è¶…æ™‚è¨­ç½®
```cpp
âœ… ç‚ºæ¯å€‹é‹å‹•è¨­ç½®åˆç†çš„è¶…æ™‚
// çŸ­è·é›¢ç§»å‹•
lemlib::moveToPoint(target, 3_sec, {}, {});

// é•·è·é›¢è·¯å¾‘
lemlib::follow(path, 8_in, 20_sec, {}, {});

âŒ ä¸è¦è¨­ç½®éé•·çš„è¶…æ™‚ (æœƒå¡ä½ç¨‹åº)
```

### 4. èª¿è©¦æŠ€å·§
```cpp
âœ… ä½¿ç”¨æ—¥èªŒè¼¸å‡º
terminal.setLoggingLevel(logger::Level::DEBUG);

âœ… LCD å¯¦æ™‚é¡¯ç¤ºé—œéµä¿¡æ¯
pros::lcd::print(0, "X: %f Y: %f", x, y);

âœ… åˆ†æ­¥æ¸¬è©¦ï¼Œé€å€‹åŠŸèƒ½é©—è­‰
```

---

## ğŸ“š é™„éŒ„

### A. å¸¸ç”¨æ•¸å€¼åƒè€ƒ

#### é¦¬é”åŠŸç‡ç¯„åœ
```
å…§éƒ¨ç¯„åœ: -1.0 åˆ° 1.0 (æ­¸ä¸€åŒ–)
PROS ç¯„åœ: -127 åˆ° 127 (å…§éƒ¨è½‰æ›)
ç™¾åˆ†æ¯”: -100% åˆ° 100%
```

#### å¸¸ç”¨é€Ÿåº¦
```
å…¨é€Ÿ: 1.0 (100%)
é«˜é€Ÿ: 0.8-0.9 (80-90%)
ä¸­é€Ÿ: 0.5-0.7 (50-70%)
ä½é€Ÿ: 0.3-0.5 (30-50%)
æœ€å°é€Ÿåº¦: 0.2-0.3 (20-30%)
```

#### settling æ¨¡å¼åƒæ•¸
```
é€²å…¥è·é›¢: 7.5 è‹±å¯¸
æœ€å°é€Ÿåº¦: 0.47 (47%)
è§’å‘è¼¸å‡º: 0 (åœæ­¢è½‰å‘)
```

---

### B. å–®ä½æ›ç®—è¡¨

| é•·åº¦ | è‹±å¯¸ | å˜ç±³ | ç±³ |
|------|------|------|-----|
| 1 è‹±å¯¸ | 1 | 2.54 | 0.0254 |
| 1 å˜ç±³ | 0.3937 | 1 | 0.01 |
| 1 ç±³ | 39.37 | 100 | 1 |

| è§’åº¦ | åº¦ | å¼§åº¦ | å˜åº¦ |
|------|-----|------|------|
| 1Â° | 1 | 0.01745 | 100 |
| 1 å¼§åº¦ | 57.296 | 1 | 5729.6 |
| 1 å˜åº¦ | 0.01 | 0.0001745 | 1 |

---

### C. éŒ¯èª¤ä»£ç¢¼å°ç…§

| éŒ¯èª¤é¡å‹ | å¯èƒ½åŸå›  | è§£æ±ºæ–¹æ³• |
|----------|----------|----------|
| é¦¬é”æº«åº¦éé«˜ | è² è¼‰éå¤§ã€å µè½‰ | æª¢æŸ¥æ©Ÿæ¢°çµæ§‹ã€é™ä½é€Ÿåº¦ |
| IMU æ ¡æº–å¤±æ•— | æ©Ÿå™¨äººç§»å‹•ã€å¹²æ“¾ | ä¿æŒéœæ­¢ã€é‡æ–°æ ¡æº– |
| ç·¨ç¢¼å™¨è®€æ•¸ç•°å¸¸ | é€£æ¥å•é¡Œã€æå£ | æª¢æŸ¥æ¥ç·šã€æ›´æ›ç·¨ç¢¼å™¨ |
| ä½ç½®è·³èº | é‡Œç¨‹è¨ˆèª¤å·® | é‡æ–°æ ¡æº–ã€æª¢æŸ¥è¼ªå¾‘ |

---

### D. ç‰ˆæœ¬æ­·å²

#### v0.6.0 (2025-11-08)
- âœ¨ æ–°å¢è·¯å¾‘è·Ÿéš¨åŠŸèƒ½
- ğŸ› ä¿®æ­£ moveToPoint settling æ¨¡å¼ bug
- ğŸ”§ å„ªåŒ– PID åƒæ•¸
- ğŸ“ å®Œå–„æ–‡æª”

---

## ğŸ“ æ”¯æ´èˆ‡è¯ç¹«

- **GitHub**: [Tsubasa1001-lang/LemLib_master](https://github.com/Tsubasa1001-lang/LemLib_master)
- **LemLib å®˜æ–¹**: [https://lemlib.github.io/LemLib/](https://lemlib.github.io/LemLib/)
- **PROS æ–‡æª”**: [https://pros.cs.purdue.edu/](https://pros.cs.purdue.edu/)

---

## ğŸ“„ æˆæ¬Š

æœ¬å°ˆæ¡ˆåŸºæ–¼ LemLib é–‹æºæ¡†æ¶é–‹ç™¼ï¼Œéµå¾ªç›¸æ‡‰çš„é–‹æºå”è­°ã€‚

---

**æ–‡æª”æœ€å¾Œæ›´æ–°**: 2025å¹´11æœˆ8æ—¥  
**æ–‡æª”ç‰ˆæœ¬**: 1.0.0
